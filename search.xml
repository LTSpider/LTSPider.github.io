<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>运维工程师岗位面试题</title>
      <link href="/2019/07/26/%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/07/26/%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>笔者其实没有想到去面试，只是在智联上更新了一下简历，就陆陆续续接到很多猎头的邮件和电话，实在是没准备好要去面试，就推掉了几家公司的面试了。正因为笔者也很久没有面试了，笔者也想去面试学习一下，闲话少说，下面就分享给大家笔者在2019年1月4号上午10点30分的面试经历：</p><p>首先，猎头或者公司人资会把公司的介绍及岗位要求发到你邮箱（或者QQ、微信），下面这份是猎头发给我的岗位说明，为了职业道德操守，公司的介绍和面试通知信息我就不贴出来了，我就把岗位要求贴出来：</p><p>职位描述：</p><p>1、 负责应用服务器的安装、配置、优化与维护；</p><p>2、 负责应用系统的日志信息备份、管理、维护与分析；</p><p>3、 负责应用系统的日常监测于维护、故障处理、性能分析与优化；</p><p>4、 负责应用部署系统、环境配置系统、监控系统的开发、部署、升级与维护，建设高性能的运维平台。</p><p>岗位要求:</p><p>1、 熟悉Linux操作系统的基础知识，熟练使用Linux常用操作命令；</p><p>2、 熟练配置Nginx、HAproxy 等应用相关软件的部署、配置与优化维护；</p><p>3、 熟悉网络基础知识、熟悉TCP/IP的工作原理，会配交换机或路由器，能熟练的对网络情况进行分析</p><p>4、 熟悉shell/perl/python中的一种或多种进行运维程序的开发；</p><p>5、 熟悉Nagios,Ganglia等监控软件</p><p>看着上面的要求大家是不是觉得要求也不高啊，你要细看就会发现，这家公司要求的还挺多，不仅要会网络知识（熟悉TCP/IP好像是每家单位的都会写这样的要求），还要会开发技能。相信很多做运维的兄弟在网络这一块是个头疼的事情，都对交换机和路由器不怎么会配置和管理。</p><p>然后，笔者详细了解他们公司，了解岗位要求，在突击复习一下可能会问到的知识点和技术点。到了面试的这天时间，早早的起床，把牙一定要刷干净，特别是有口臭的兄弟，最好准备点口香糖，到达面试公司前嚼块口香糖，以免因为口气的原因熏到面试官，让你在面试官心里减分。早点要记得吃，如果你是下午面试的话也要吃午饭，吃早点了精气神就有了。还要注意，带上你的简历和一支笔，虽然他们那边也会有你的简历，为了以防万一还是准备好简历。</p><p>最后，关键点来了，就是和面试官沟通了，有笔试的公司会让你做些面试题，没有笔试就直接和面试官聊了，下面是我和面试官沟通完之后记住的一些问题，分享给大家看一下，笔者一共记住了7个问题，好像还有两个问题实在想不起来了，如果大家有更恰当的回答一定要贴出来一起探讨和进步：</p><p>1、介绍下自己？（几乎每家公司首先都会让你做个自我介绍，好像是必修课一样）</p><p>笔者回答：此处省略笔者的自我介绍，笔者建议介绍自己的时间不宜过长，3-4分钟为宜，说多了面试官会觉得你太啰嗦了。说太少了也不行，那样会让人感觉你的经历太简单了、太空了。正常情况下，一般你在做自我介绍的同时，面试官这个时候在看你的简历，他需要一边看简历、一边听你介绍自己，如果你说个几句话就把自己介绍完了，他肯定还没缓过神来，对你的映像会减分的。在介绍的同时思维要清晰，逻辑要清楚，最好是根据你简历上写的经历来介绍，这样可以把面试官的思路带到你这里来，让他思路跟着你走。不要东扯一句，西扯一句。竟量少介绍自己的性格、爱好（最好能不说就不说），你可以简单罗列干过几家公司（最多罗列3家公司/也包含目前所在的公司，注意顺序不要乱），都在那几家公司负责什么工作，都用过什么技术，在着重介绍一下你目前所在的公司是负责哪些工作的，可以稍微详细一点介绍，不要让面试官听着晕头转向的感觉。</p><p>2、灰度发布如何实现？</p><p>笔者回答：其实对这个问题笔者也答的不好，就不写出来误导大家了。大家有好的方法可以共享出来。不过笔事后在知呼上看到了一位网友的建议觉得不错，大家可以参考看一下 ：<a href="https://www.zhihu.com/question/20584476" target="_blank" rel="noopener">https://www.zhihu.com/question/20584476</a></p><p>3、Mongodb熟悉吗，一般部署几台？</p><p>笔者回答：部署过，没有深入研究过，一般mongodb部署主从、或者mongodb分片集群；建议3台或5台服务器来部署。MongoDB分片的基本思想就是将集合切分成小块。这些块分散到若干片里面，每个片只负责总数据的一部分。  对于客户端来说，无需知道数据被拆分了，也无需知道服务端哪个分片对应哪些数据。数据在分片之前需要运行一个路由进程，进程名为mongos。这个路由器知道所有数据的存放位置，知道数据和片的对应关系。对客户端来说，它仅知道连接了一个普通的mongod，在请求数据的过程中，通过路由器上的数据和片的对应关系，路由到目标数据所在的片上，如果请求有了回应，路由器将其收集起来回送给客户端。</p><p>4、如何发布和回滚，用jenkins又是怎么实现？</p><p>笔者回答：发布：jenkins配置好代码路径（SVN或GIT），然后拉代码，打tag。需要编译就编译，编译之后推送到发布服务器（jenkins里面可以调脚本），然后从分发服务器往下分发到业务服务器上。</p><p>回滚：按照版本号到发布服务器找到对应的版本推送</p><p>5、Tomcat工作模式？</p><p>笔者回答：Tomcat是一个JSP/Servlet容器。其作为Servlet容器，有三种工作模式：独立的Servlet容器、进程内的Servlet容器和进程外的Servlet容器。</p><p>进入Tomcat的请求可以根据Tomcat的工作模式分为如下两类：</p><p>Tomcat作为应用程序服务器：请求来自于前端的web服务器，这可能是Apache, IIS, Nginx等；</p><p>Tomcat作为独立服务器：请求来自于web浏览器；</p><p>6、监控用什么实现的？</p><p>笔者回答：现在公司的业务都跑在阿里云上，我们首选的监控就是用阿里云监控，阿里云监控自带了ECS、RDS等服务的监控模板，可结合自定义报警规则来触发监控项。上家公司的业务是托管在IDC，用的是zabbix监控方案，zabbix图形界面丰富，也自带很多监控模板，特别是多个分区、多个网卡等自动发现并进行监控做得非常不错，不过需要在每台客户机（被监控端）安装zabbix agent。</p><p>7、你是怎么备份数据的，包括数据库备份？</p><p>笔者回答：在生产环境下，不管是应用数据、还是数据库数据首先在部署的时候就会有主从架构、或者集群，这本身就是属于数据的热备份；其实考虑冷备份，用专门一台服务器做为备份服务器，比如可以用rsync+inotify配合计划任务来实现数据的冷备份，如果是发版的包备份，正常情况下有台发布服务器，每次发版都会保存好发版的包。</p><p>总结一下面试注意几点事项，可能笔者也说得不太对，为了我们运维工作的兄弟们都能拿到高薪，大家一定要指证出来一起进步、一起探讨：</p><p>第一，你要对自己的简历很熟悉，简历上的写的技能自己一定要能说出个一二，因为面试官的很多问题都会挑你简历上写的问。比如你简历上写了这么一条技能“熟悉mysql数据库的部署安装及原理”。你即然写了这么一条技能，你在怎么不熟悉你也要了解mysql的原理，能说出个大概意思。万一面试官问到了你写的这一条，你都答不上来，那在他心里你又减分了，基本上这次面试希望不大。</p><p>第二，如果面试官问到你不会的问题，你就说这个不太熟悉，没有具体研究过，千万别不懂装懂，还扯一堆没用的话题来掩饰，这样只会让面试官反感你。</p><p>第三，准备充分，竟可能多的记住原理性的知识，一般面试问的多的就是原理。很少问具体的配置文件是怎么配置的。面试前也要了解清楚“职位描述”和“岗位要求”，虽然有时候大多数不会问到岗位要求的问题，但也要了解和熟悉。</p><p>第四，面试完后一定要总结，尽量记住面试官问的每一个问题，回去记录下来，如果问到不会的问题，事后要立马查百度或者找朋友搞清楚、弄明白，这样你才能记劳，下次面试说不定又问到同样的问题。</p><p>问完之后，面试官就跟我聊薪资待遇了，问我多少钱能达到自己的要求，我就不便透露了，可以私聊，哈哈，后续笔者会陆陆续续更新以前面试的经历和问题，有需要的朋友可以转载或者收藏起来一起讨论。</p><p>岗位职责：<br>1、负责公司产品的版本控制、构建和发布管理；<br>2、负责公司统一配置库管理工作，权限管理与分配准确及时，定期完成配置备份；<br>3、负责公司内部开发/测试服务器的运行管理工作；<br>4、负责Linux操作系统的安装、配置、监控和维护、问题处理、软件升级、 数据备份、应急响应、故障排除等、保证线上环境的稳定运行；<br>5、负责支撑平台24×7稳定运行，并进行前瞻性容量规划；<br>6、负责公司机房服务器日常维护及网络系统安装、部署、维护工作。</p><p>岗位要求：<br>1、计算机相关专业本科及以上学历，2年以上运维或配置管理工作经验；<br>2、至少熟悉一种监控系统搭建，如Nagios/Zabbix/等；<br>3、至少熟悉一种集群管理工具，如Ansible/SaltStack等；<br>4、有使用集成发布工具发布构建经验优先。比如：bamboo或者Jenkins；<br>5、熟悉Unix/Linux操作系统，熟悉Weblogic/tomcat等中间件，能够编写shell脚本，熟悉软件开发过程及过程产品，有一定的网络基础；<br>6、熟悉rsyslog, flume等日志收集和处理系统；<br>7、具有强烈的安全意识及较强的沟通协调和学习能力，良好的团队合作精神，工作积极主动。</p><p>过去之后，前台美眉把我带到他们公司的地下室，我扫视了一下周围的环境，貌似旁边就是机房，因为我听到服务器的声音。等了几分钟，面试官下来了，面试官目测比较瘦，看着跟我身材差不多（应该不到120），他说他是负责运维部的，然后开始就叫我先自我介绍，都是一个套路，免不了介绍的，所以兄弟们一定要把自我介绍练好。然后开始问我问题了，跟面试官聊得还行，问我应该有不下10个以上的问题，我记住了下面有10个问题：</p><p>1、LVS负载的原理，和Nginx负载有啥区别？</p><p>笔者回答：这个问题我觉得面试官司没问好，正常都会这么问“LVS有哪些负载均衡技术和调度算法?”。我回答就是按我说的这种问法回答的，反正他也频繁点头，当然，笔者回答的可能没有下面我整理出来的那么详细，大概意思我都说明白了。</p><p>LVS是Liunx虚拟服务器的简称，利用LVS提供的负载均衡技术和linux操作系统可实现高性能、高可用的服务器集群，一般LVS都是位于整个集群系统的最前端，由一台或者多台负载调度器（Director Server）组成，分发给应用服务器（Real Server）。它是工作在4层（也就是TCP/IP中的传输层），LVS是基于IP负载均衡技术的IPVS模块来实现的，IPVS实现负载均衡机制有三种，分别是NAT、TUN和DR，详述如下：</p><p> VS/NAT： 即（Virtual Server via Network Address Translation）</p><p>也就是网络地址翻译技术实现虚拟服务器，当用户请求到达调度器时，调度器将请求报文的目标地址（即虚拟IP地址）改写成选定的Real Server地址，同时报文的目标端口也改成选定的Real Server的相应端口，最后将报文请求发送到选定的Real Server。在服务器端得到数据后，Real Server返回数据给用户时，需要再次经过负载调度器将报文的源地址和源端口改成虚拟IP地址和相应端口，然后把数据发送给用户，完成整个负载调度过程。</p><p>可以看出，在NAT方式下，用户请求和响应报文都必须经过Director Server地址重写，当用户请求越来越多时，调度器的处理能力将称为瓶颈。</p><p> VS/TUN ：即（Virtual Server via IP Tunneling）</p><p>也就是IP隧道技术实现虚拟服务器。它的连接调度和管理与VS/NAT方式一样，只是它的报文转发方法不同，VS/TUN方式中，调度器采用IP隧道技术将用户请求转发到某个Real Server，而这个Real Server将直接响应用户的请求，不再经过前端调度器，此外，对Real Server的地域位置没有要求，可以和Director Server位于同一个网段，也可以是独立的一个网络。因此，在TUN方式中，调度器将只处理用户的报文请求，集群系统的吞吐量大大提高。</p><p> VS/DR： 即（Virtual Server via Direct Routing）</p><p>也就是用直接路由技术实现虚拟服务器。它的连接调度和管理与VS/NAT和VS/TUN中的一样，但它的报文转发方法又有不同，VS/DR通过改写请求报文的MAC地址，将请求发送到Real Server，而Real Server将响应直接返回给客户，免去了VS/TUN中的IP隧道开销。这种方式是三种负载调度机制中性能最高最好的，但是必须要求Director Server与Real Server都有一块网卡连在同一物理网段上。</p><p>回答负载调度算法，IPVS实现在八种负载调度算法，我们常用的有四种调度算法（轮叫调度、加权轮叫调度、最少链接调度、加权最少链接调度）。一般说了这四种就够了，也不会需要你详细解释这四种算法的。你只要把上面3种负载均衡技术讲明白面试官就对这道问题很满意了。接下来你在简单说下与nginx的区别：</p><p>LVS的优点：</p><p>抗负载能力强、工作在第4层仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的；无流量，同时保证了均衡器IO的性能不会受到大流量的影响；<br>工作稳定，自身有完整的双机热备方案，如LVS+Keepalived和LVS+Heartbeat；<br>应用范围比较广，可以对所有应用做负载均衡；<br>配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。<br>LVS的缺点：</p><p>软件本身不支持正则处理，不能做动静分离，这就凸显了Nginx/HAProxy+Keepalived的优势。<br>如果网站应用比较庞大，LVS/DR+Keepalived就比较复杂了，特别是后面有Windows Server应用的机器，实施及配置还有维护过程就比较麻烦，相对而言，Nginx/HAProxy+Keepalived就简单一点<br>Nginx的优点：</p><p>工作在OSI第7层，可以针对http应用做一些分流的策略。比如针对域名、目录结构。它的正则比HAProxy更为强大和灵活；<br>Nginx对网络的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势所在；<br>Nginx安装和配置比较简单，测试起来比较方便；<br>可以承担高的负载压力且稳定，一般能支撑超过几万次的并发量；<br>Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点；<br>Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP现在也是非常流行的web环境，大有和LAMP环境分庭抗礼之势，Nginx在处理静态页面、特别是抗高并发方面相对apache有优势；<br>Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，有需求的朋友可以考虑用其作为反向代理加速器；<br>Nginx的缺点：</p><p>Nginx不支持url来检测。<br>Nginx仅能支持http和Email，这个它的弱势。<br>Nginx的Session的保持，Cookie的引导能力相对欠缺。</p><p>2、redis集群的原理，redis分片是怎么实现的，你们公司redis用在了哪些环境？</p><p>笔者回答：reids集群原理：</p><p>其实它的原理不是三两句话能说明白的，redis 3.0版本之前是不支持集群的，官方推荐最大的节点数量为1000，至少需要3(Master)+3(Slave)才能建立集群，是无中心的分布式存储架构，可以在多个节点之间进行数据共享，解决了Redis高可用、可扩展等问题。集群可以将数据自动切分(split)到多个节点，当集群中的某一个节点故障时，redis还可以继续处理客户端的请求。</p><p>redis分片：</p><p>分片(partitioning)就是将你的数据拆分到多个 Redis 实例的过程，这样每个实例将只包含所有键的子集。当数据量大的时候,把数据分散存入多个数据库中,减少单节点的连接压力,实现海量数据存储。分片部署方式一般分为以下三种：</p><p>（1）在客户端做分片；这种方式在客户端确定要连接的redis实例，然后直接访问相应的redis实例；</p><p>（2）在代理中做分片；这种方式中，客户端并不直接访问redis实例，它也不知道自己要访问的具体是哪个redis实例，而是由代理转发请求和结果；其工作过程为：客户端先将请求发送给代理，代理通过分片算法确定要访问的是哪个redis实例，然后将请求发送给相应的redis实例，redis实例将结果返回给代理，代理最后将结果返回给客户端。</p><p>（3）在redis服务器端做分片；这种方式被称为“查询路由”，在这种方式中客户端随机选择一个redis实例发送请求，如果所请求的内容不再当前redis实例中它会负责将请求转交给正确的redis实例，也有的实现中，redis实例不会转发请求，而是将正确redis的信息发给客户端，由客户端再去向正确的redis实例发送请求。</p><p>redis用在了哪些环境：</p><p>java、php环境用到了redis，主要缓存有登录用户信息数据、设备详情数据、会员签到数据等</p><p>3、你会怎么统计当前访问的IP，并排序？</p><p>笔者回答：统计用户的访问IP，用awk结合uniq、sort过滤access.log日志就能统计并排序好。一般这么回答就够了，当然你还可以说出其它方式来统计，这都是你的加分项。</p><p>4、你会使用哪些虚拟化技术？</p><p>笔者回答：vmware vsphere及kvm，我用得比较多的是vmware vsphere虚拟化，几本上生产环境都用的vmware vsphere，kvm我是用在测试环境中使用。vmware 是属于原生架构虚拟化技术，也就是可直接在硬件上运行。kvm属于寄居架构的虚拟化技术，它是依托在系统之上运行。vmware vcenter</p><p>管理上比较方便，图形管理界面功能很强大，稳定性强，一般比较适合企业使用。KVM管理界面稍差点，需要管理人员花费点时间学习它的维护管理技术。</p><p>5、假如有人反应，调取后端接口时特别慢，你会如何排查？</p><p>笔者回答：其实这种问题都没有具体答案，只是看你回答的内容与面试官契合度有多高，能不能说到他想要的点上，主要是看你排查问题的思路。我是这么说的：问清楚反应的人哪个服务应用或者页面调取哪个接口慢，叫他把页面或相关的URL发给你，首先，最直观的分析就是用浏览器按F12，看下是哪一块的内容过慢（DNS解析、网络加载、大图片、还是某个文件内容等），如果有，就对症下药去解决（图片慢就优化图片、网络慢就查看内网情况等）。其次，看后端服务的日志，其实大多数的问题看相关日志是最有效分析，最好用tail -f 跟踪一下日志，当然你也要点击测试来访问接口日志才会打出来。最后，排除sql，，找到sql去mysql执行一下，看看时间是否很久，如果很久，就要优化SQL问题了，expain一下SQL看看索引情况啥的，针对性优化。数据量太大的能分表就分表，能分库就分库。如果SQL没啥问题，那可能就是写的逻辑代码的问题了，一行行审代码，找到耗时的地方改造，优化逻辑。</p><p>6、mysql数据库用的是主从读写分离，主库写，从库读，假如从库无法读取了、或者从库读取特别慢，你会如何解决？</p><p>笔者回答：这个问题笔者觉得回答的不太好，对mysql比较在行的朋友希望能给点建议。以解决问题为前提条件，先添加从库数量，临时把问题给解决，然后抓取slow log ，分析sql语句，该优化就优化处理。慢要不就是硬件跟不上，需要升级；要不就是软件需要调试优化，等问题解决在细化。</p><p>7、cpu单核和多核有啥区别？</p><p>笔者回答：很少有面试官会问这样的问题，即然问到了，也要老实回答。还好笔者之前了解过CPU，我是这么说的：双核CPU就是能处理多份任务，顺序排成队列来处理。单核CPU一次处理一份任务，轮流处理每个程序任务。双核的优势不是频率，而是对付同时处理多件事情。单核同时只能干一件事，比如你同时在后台BT下载，前台一边看电影一边拷贝文件一边QQ。</p><p>8、机械磁盘和固态硬盘有啥区别？</p><p>笔者回答：我擦，啥年代了，还问磁盘的问题，这面试官有点逗啊。那也要回答啊：</p><p>HDD代表机械硬盘，SSD代表固态硬盘。首先，从性能方面来说，固态硬盘几乎完胜机械硬盘，固态硬盘的读写速度肯定要快机械硬盘，因为固态硬盘和机械硬盘的构造是完全不同的（具体的构造就没必要解释了）。其次，固态盘几乎没有噪音、而机械盘噪音比较大。还有就是，以目前的市场情况来看，一般机械盘容量大，价格低；固态盘容量小，价格偏高。但是企业还是首选固态盘。</p><p>9、说一下用过哪些监控系统？</p><p>笔者回答：这个监控的问题又问到了，笔者在2019年1月4号也被问到类似这样的问题，笔者曾经用过zabbix、nagios、 cacit等。但是在这次面试中只说用过zabbix和nagios。说完了之后，面试官就让我说一下这两个监控有啥区别：</p><p>从web功能及画图来讲：</p><p>Nagios简单直观，报警与数据都在同一页面， 红色即为问题项。Nagios web端不要做任何配置。  Nagios需要额外安装插件，且插件画图不够美观。</p><p>   Zabbix监控数据与报警是分开的，查看问题项需要看触发器，查看数据在最新数据查看。而且zabbix有很多其它配置项，  zabbix携带画图功能，且能手动把多个监控项集在一个图中展示。</p><p>从监控服务来讲：</p><p>Nagios自带的监控项很少。对一些变动的如多个分区、多个网卡进行监控时需要手动配置。</p><p>Zabbix自带了很多监控内容，感觉zabbix一开始就为你做了很多事，特别是对多个分区、多个网卡等自动发现并进行监控时，那一瞬间很惊喜，很省心的感觉。</p><p>从批量配置和报警来讲：</p><p>Nagios对于批量监控主机，需要用脚本在server端新增host，并拷贝service文件。   Nagios用脚本来修改所有主机的services文件，加入新增服务。</p><p>  Zabbix在server端配置自动注册规则，配置好规则后，后续新增client端不需要对server端进行操作。  Zabbix只需手动在模板中新增一监控项即可。</p><p>总体来讲：</p><p>Nagios要花很多时间写插件，Zabbix要花很多时间探索功能。</p><p>Nagios更易上手，Nagios两天弄会，Zabbix两周弄会。</p><p>Zabbix画图功能比Nagios更强大</p><p>Zabbix对于批量监控与服务更改，操作更简洁；Nagios如果写好自动化脚本后，也很简单，问题在于写自动化脚本很费神。</p><p>10、给你一套环境，你会如何设计高可用、高并发的架构？</p><p>笔者回答：</p><p>如果这套环境是部署在云端(比如阿里云)，你就不用去考虑硬件设计的问题。可直接上阿里云的SLB+ECS+RDS这套标准的高可用、高并发的架构。对外服务直接上SLB负载均衡技术，由阿里的SLB分发到后端的ECS主机；ECS主机部署多台，应用拆分在不同的ECS主机上，尽量细分服务。数据库用RDS高可用版本（一主一备的经典高可用架构）、或者用RDS金融版（一主两备的三节点架构）。在结合阿里其它的服务就完全OK，业务量上来了，主机不够用了，直横向扩容ECS主机搞定。</p><p>如果这套环境托管在IDC，那么你就要从硬件、软件（应用服务）双面去考虑了。硬件要达到高可用、高并发公司必须买多套网络硬件设备（比如负载设备F5、防火墙、核心层交换、接入层交换）都必须要冗余，由其是在网络设计上，设备之间都必须有双线连接。设备如果都是跑的单机，其中一个设备挂了，你整个网络都瘫痪了，就谈不上高可用、高并发了。其次在是考虑应用服务了，对外服务我会采用成熟的开源方案LVS+Keepalived或者Nginx+Keepalived，缓存层可以考虑redis集群及Mongodb集群，中间件等其它服务可以用kafka、zookeeper，图片存储可以用fastDFS或MFS，如果数据量大、又非常多，那么可采用hadoop这一套方案。后端数据库可采用 “主从+MHA”。这样一套环境下来是绝对满足高可用、高并发的架构。</p><p>岗位职责：<br>1、日常线上项目的需求处理；<br>2、新项目上线对接的相关工作；<br>3、日常运维工具开发、维护、优化；<br>4、监控业务的运行状态，及时处理项目运行中出现的故障，保障项目服务24x7稳定运行；<br>5、分析排除系统、数据库、网络、应用等故障及错误；<br>6、负责服务器的资源调配和系统安全、数据备份。<br>任职要求：</p><ol><li><p>熟悉linux操作系统， 熟练使用一种或多种脚本语 言（例如 Python/Perl/Shell）；</p></li><li><p>熟悉至少一种共有云技术，多种运维平台工具（Nagios, Zabbix，Puppet等）</p></li><li><p>熟悉Nginx,Mysql, Redis, Keepalived, LVS等中间件的配置与调优；</p></li><li><p>熟悉网络部署，多种数据机房故障的发现和排除的工具，有做个跨机房数据同步的优先；</p></li><li><p>熟悉mysql、redis、mongoDB的安装、维护、性能优化；</p></li><li><p>了解反向代理、负载均衡原理.</p></li><li><p>有责任心，耐心，积极肯学的心态以及良好的沟通表达能力和团队合作精神；   </p><p> 其实这个要求，我在上一篇文章也说到过，大多数公司都写得差不多，很多公司自己懒的写，直接照搬别的公司发出来岗位要求，所以我们只要了解它就可以了，面试的时候不一定会问到这些岗位的要求说明，你看这家公司没有写熟悉TCP/IP，其实面试官这一次有问到TCP/IP这个问题的。这次技术面试后总体面试官还是比较满意，后来猎头通知我一面过了，准备安排2018年1月11号下午进行二面（跟我谈薪资、对海外工作的想法、人生规划等话题）。好了，不多说了，大家自己慢慢看我和面试官聊的技术问题吧。</p></li></ol><p>1、介绍下自己？</p><p>笔者回答：不管是电话面试还是现场面试，自我介绍是避免不了的，上一篇文章我有详细介绍这块的内容，这里不做解释了，感兴趣的朋友参考我上一篇文章：</p><p>  总结一下：运维工程师面试的经历及面试相关问题（会持续更新）</p><p>2、为什么想着要离开现在的公司？</p><p>笔者回答：虽然是面试技术，但也会有很多面试官会不经意的问你这个问题，看起来很随意的问题，其实这个问题里面隐藏了很多信息，最直观的就是看你这个人对企业的忠诚度、还能看你是不是心浮气燥的性格等等。如果你曾经频繁跳过槽，不管出于什么原因，笔者个人都不建议写在简历上，最好能够合并一些工作时间和单位，企业是很担心把你招来后会不会短时间你又跳槽了。当然如果都是因为企业经营不善倒闭所至，就没关系了。说到这里，就想起了笔者曾经一位同事，连续在好几家单位都干倒闭了，这我也不知道说啥好了。。。好了，咋们接着往下走。</p><p>3、TCP/IP原理说一下？TCP有哪几个状态，分别是什么意思？</p><p>笔者回答：以tcp/ip协议为核心,分五层。tcp工作在第4层，主要有tcp和udp协议。其中tcp是可靠协议，udp是不可靠协议。 tcp传输之前，需要建立连接，通过三次握手实现。</p><p>TCP三次握手状态：首先是closed状态，当发起连接后，进入Listen状态，当三次握手之后，进入EST状态。三次握手中间还有一个临时状态:SYN_SENT。SYN_SENT 当应用程序发送ack之后，进入EST状态,如果没有发送，就关闭closed.</p><p>总结：大家一定要熟记tcp状态转换图，参考 <a href="http://blog.csdn.net/wenqian1991/article/details/40110703" target="_blank" rel="noopener">http://blog.csdn.net/wenqian1991/article/details/40110703</a> 如下图：</p><p>image.png</p><p>4、有个客户说访问不到你们的网站，但是你们自己测试内网和外网访问都没问题。你会怎么排查并解决客户的问题？</p><p>笔者回答：我们自己测了都没问题，只是这个客户访问有问题，那肯定是要先联系到这个客户，能远程最好，问一下客户的网络是不是正常的，访问其它的网站有没有问题（比如京东、百度什么的）。如果访问其它网站有问题，那叫客户解决本身网络问题。如果访问其它网站都没问题，用ping和nslookup解析一下我们的网站是不是正常的，让客户用IP来访问我们的网站是否可行，如果IP访问没问题，那就是客户的DNS服务器有问题或者DNS服务器解析不到我们的网站。还有一种可能就是跨运营商访问的问题，比如我们的服务器用的是北方联通、而客户用的是南方移动，就也有可能突然在某个时间段访问不到，这种情况在庞大的中国网络环境中经常发生（一般是靠CDN解决）。还有可能就是我们的网站没有SSL证书，在公网是使用的是http协议，这种情况有可能就是没有用https协议网站被运营商劫持了。</p><p>5、redhat 6.X版本系统 和 centos 7.X版本有啥区别？</p><p>笔者回答：桌面系统（6/GNOE2.x、7/GNOME3.x）、文件系统（6/ext4、7/xfs）、内核版本（6/2.6x、7/3.10x）、防火墙（6/iptables、7/firewalld）、默认数据库（6/mysql、7/mariadb）、启动服务（6/service启动、7/systemctl启动）、网卡（6/eth0、7/ens192）等。</p><p>6、你会用什么方法查看某个应用服务的流量使用情况？</p><p>笔者回答：如果是单一应用的服务器，只需要用iftop、sar等工具统计网卡流量就可以。如果服务器跑了多个应用，可以使用nethogs工具实现，它的特别之处在于可以显示每个进程的带宽占用情况，这样可以更直观获取网络使用情况。</p><p>7、说一下你们公司怎么发版的（代码怎么发布的）？</p><p>笔者回答：我说什么来着，这个问题又问到了。发布：jenkins配置好代码路径（SVN或GIT），然后拉代码，打tag。需要编译就编译，编译之后推送到发布服务器（jenkins里面可以调脚本），然后从分发服务器往下分发到业务服务器上。</p><p>8、elk中的logstash是怎么收集日志的，在客户端的logstash配置文件主要有哪些内容？</p><p>笔者回答：input、output两大块配置；input中指定日志（type、path）等，output指定日志输出的目标（host、port）等。</p><p>9、ansible你用过它的哪些模块，ansbile同时分发多台服务器的过程很慢（它是逐台分发的），你想过怎么解决吗？</p><p>笔者回答：用过ansible的（copy file yum ping command shell）等模块；ansible默认只会创建5个进程,所以一次任务只能同时控制5台机器执行.那如果你有大量的机器需要控制,或者你希望减少进程数,那你可以采取异步执行.ansible的模块可以把task放进后台,然后轮询它.这使得在一定进程数下能让大量需要的机器同时运作起来.</p><p>10、nginx有哪几种调度算法，解释一下ip  hash和轮询有啥不一样？</p><p>笔者回答：常用的有3种调度算法（轮询、ip hash、权重）。</p><p>轮询：upstream按照轮询（默认）方式进行负载，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><p>ip hash：每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><p>权重：指定轮询几率，权重（weight）和访问比率成正比，用于后端服务器性能不均的情况。</p><p>11、nginx你用到了哪些模块，在proxy模块中你配置过哪些参数？</p><p>笔者回答：用到过（负载均衡upstream、反向代理proxy_pass、location、rewrite等）。</p><p>proxy模块中配置过:proxy_set_header、proxy_connect_timeout、proxy_send_timeout、proxy_buffer_*</p><p>12、说一下iptables的原理，有哪些表、哪些链？怎么修改默认策略全部为DROP?</p><p>笔者回答：iptables是工作在TCP/IP的2、3、4层。你要说它的原理也不是几话能概括的，当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身，则传到用户空间中交给对应的应用程序处理，若发现目的不是自身，则会将包丢弃或进行转发。</p><p>4张表（raw表、mangle表、net表、filter表）</p><p>5条链（INPUT链、OUTPUT链、PORWARD链、PREROUTING链、POSTROUTING链）。</p><p>全部设置为DROP：</p><p>#iptables -P INPUT DROP</p><p>#iptables -P OUTPUT DROP</p><p>#iptables -P FORWARD DROP</p><p>小结：iptables远不止这几句话就能描述清楚的，也不是随便在网上趴些资料就能学好的，需要自己用起来，经过大量的实验和实战才能熟悉它，iptables真的很考验运维人员的技术水平，大家一定要用心学好这个iptables。</p><p>13、如何开启linux服务器路由转发功能？</p><p>笔者回答：echo “1” &gt; /proc/sys/net/ipv4/ip_forward</p><p>14、nginx中rewrite有哪几个flag标志位（last、break、redirect、permanent），说一下都什么意思？</p><p>笔者回答：</p><p>last : 相当于Apache的[L]标记，表示完成当前的rewrite规则<br>break : 停止执行当前虚拟主机的后续rewrite指令集<br>redirect : 返回302临时重定向，地址栏会显示跳转后的地址<br>permanent : 返回301永久重定向，地址栏会显示跳转后的地址<br>301和302不能简单的只返回状态码，还必须有重定向的URL，这就是return指令无法返回301,302的原因了。这里 last 和 break 区别有点难以理解：</p><p>last一般写在server和if中，而break一般使用在location中<br>last不终止重写后的url匹配，即新的url会再从server走一遍匹配流程，而break终止重写后匹配<br>break和last都能组织继续执行后面的rewrite指令<br>总结：关于nginx rewrite用法，笔者看到一篇文章总结的挺不错 ，可以参考一下 <a href="https://www.jianshu.com/p/a1fce9358d44" target="_blank" rel="noopener">https://www.jianshu.com/p/a1fce9358d44</a></p><p>15、你在shell脚本中用过哪些语法，case语法会用到哪些地方？</p><p>笔者回答：一般会用到if语句、for语句、while语句、case语句以及function函数的定义；case语句为多选择语句，可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。最典型的case语法会用到启动服务脚本的处理。</p><p>16、linux系统中你会用到什么命令查看硬件使用状态信息？</p><p>笔者回答：这个命令就很多了，比如：lscpu(查看cpu信息)、free -m（查看内存信息）、df -h（查看硬盘分区信息）、top（还可以动态查看cpu、内存使用情况的信息），/proc/目录下也可以查看很多硬件信息。</p><p>17、我要过滤一段文本(test.txt)中第二列的内容？如果这段文件有很多特殊符号，比如用:（冒号）怎么过滤它的第二段？如果我要过滤这段文本中，其中有一行只有7个符如何实现？</p><p>笔者回答： awk ‘{print $2}’   tset.txt</p><p>awk -F’:’  ‘{print $2}’   tset.txt</p><p>18、比如开发想找你查看tomcat日志，但是catalia.out特别大，你不可能用vi打开去看，你会怎么查看？如果你用 grep -i”error” 过滤只是包含error的行，我想同时过滤error上面和下面的行如何实现？</p><p>笔者回答：grep -i “error” catalia.out</p><p>grep -C 1  -i “error” catalia.out</p><p>参数-C：是匹配前后的行，后面1是匹配前后各1行</p><p>19、 怎么编写一个定时计划任务？里面用到的最小单位是什么？</p><p>笔者回答：crontab -e，最小单位是分钟</p><p>20、zabbix如何修改其中监控的一台服务器中内存阈值信息，比如正常内存使用到了80%报警，我想修改为60%报警？</p><p>笔者回答：正常来说，一般会把监控的服务器统一加入到一个模板中，修改模板的其是某一项的监控项参数和告警阈值后，加入模板中的所有主机都会同步。如果单独想修改其中某一台服务器内存告警阈值，需要进入这台主机，单独创建一个告警Triggers，关联这台主机监控内存的项，配置好告警的阈值为60%即可实现。其实，zabbix一切都为图形化操作，如果没有接触过zabbix的朋友，可能听起来不太清楚。</p><p>21、mysql主从复制原理说一下？</p><p>笔者回答：mysql支持三种复制类型（基于语句的复制、基于行的复制、混合类开进的复制）。</p><p>如果你记不住太多内容，可以简单说明一下原理：</p><p>(1) master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events）；</p><p>(2) slave将master的binary log events拷贝到它的中继日志(relay log)；</p><p>(3) slave重做中继日志中的事件，将改变反映它自己的数据。</p><p>20180112090827.jpg</p><p>如果你能详细记住它的原理，可以这么回答：</p><p>该过程的第一部分就是master记录二进制日志。在每个事务更新数据完成之前，master在二日志记录这些改变。MySQL将事务串行的写入二进制日志，即使事务中的语句都是交叉执行的。在事件写入二进制日志完成后，master通知存储引擎提交事务。</p><p>下一步就是slave将master的binary log拷贝到它自己的中继日志。首先，slave开始一个工作线程——I/O线程。I/O线程在master上打开一个普通的连接，然后开始binlog dump process。Binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件。I/O线程将这些事件写入中继日志。</p><p>SQL slave thread（SQL从线程）处理该过程的最后一步。SQL线程从中继日志读取事件，并重放其中的事件而更新slave的数据，使其与master中的数据一致。只要该线程与I/O线程保持一致，中继日志通常会位于OS的缓存中，所以中继日志的开销很小。</p><p>22、用什么命令可以查看上一次服务器启动的时间、上一次谁登录过服务器？</p><p>笔者回答：w命令查看上次服务器启动时间。last命令  查看登录。</p><p>23、redis集群原理说一下，正常情况下mysql有多个库，redis也有多个库，我怎么进入redis集群中的第2个库？还有，我想查看以BOSS开头的值？redis持久化是如何实现（一种是RDS、一种是AOF），说一下他们有啥不一样？</p><p>笔者回答：这个redis原理的问题又问到了，看样子很多面试官都很关心这个redis，在上一篇文章笔者的一次面试也有这个面试问题。</p><p>【集群原理】：其实它的原理不是三两句话能说明白的，redis 3.0版本之前是不支持集群的，官方推荐最大的节点数量为1000，至少需要3(Master)+3(Slave)才能建立集群，是无中心的分布式存储架构，可以在多个节点之间进行数据共享，解决了Redis高可用、可扩展等问题。集群可以将数据自动切分(split)到多个节点，当集群中的某一个节点故障时，redis还可以继续处理客户端的请求。</p><p>【切库】：单机情况下用select 2可以切换第2个库，select 1可以切换第1个库。但是集群环境下不支持select。可参考<a href="https://yq.aliyun.com/articles/69349" target="_blank" rel="noopener">https://yq.aliyun.com/articles/69349</a></p><p>【redis持久化】：持久化通俗来讲就是将内存中的数据写入硬盘中，redis提供了两种持久化的功能（RDB、AOF），默认使用RDB的方式。</p><p>RDB：全量写入持久化，而RDB持久化也分两种（SAVE、BGSAVE）。</p><p>SAVE是阻塞式的RDB持久化，当执行这个命令时redis的主进程把内存里的数据库状态写入到RDB文件（即上面的dump.rdb）中，直到该文件创建完毕的这段时间内redis将不能处理任何命令请求。</p><p>BGSAVE属于非阻塞式的持久化，它会创建一个子进程专门去把内存中的数据库状态写入RDB文件里，同时主进程还可以处理来自客户端的命令请求。但子进程基本是复制的父进程，这等于两个相同大小的redis进程在系统上运行，会造成内存使用率的大幅增加。</p><p>AOF：与RDB的保存整个redis数据库状态不同，AOF的持久化是通过命令追加、文件写入和文件同步三个步骤实现的。AOF是通过保存对redis服务端的写命令（如set、sadd、rpush）来记录数据库状态的，即保存你对redis数据库的写操作。</p><p>为了大家能够更好的理解redis持久化，笔者建议大家可以看下这两篇文章会比较好理解：</p><p><a href="https://www.cnblogs.com/Fairy-02-11/p/6182478.html" target="_blank" rel="noopener">https://www.cnblogs.com/Fairy-02-11/p/6182478.html</a></p><p><a href="http://blog.csdn.net/mishifangxiangdefeng/article/details/48977269" target="_blank" rel="noopener">http://blog.csdn.net/mishifangxiangdefeng/article/details/48977269</a></p><p>24、你在工作的过程中，遇到过你映像最深的是什么故障问题，你又是如何解决？</p><p>笔者回答：这个问题主要也是考你排查故障的思路及用到的相关命令工具，其每个人在工作中都会遇到各种各样的问题（不管是网络问题、应用配置问题、还是APP打开慢/网站打开慢）等等。你只要记住一个你映像最为深刻、最为典型的故障就行。笔者也遇到过各种问题，我在这里就是写出来，怕误导了大家。</p><p>25、在linux服务器上，不管是用rz -y命令还是tftp工具上传，我把本地的一个文件上传到服务器完成后，服务器上还是什么都没有，这有可能是什么问题？</p><p>笔者回答：根据这种现象有可能是：服务器磁盘满了；文件格式破坏了；或者你用的是普通用户上传，正好上传的目录没有权限；还有可能就是你上传的文件大小超出了该目录空间的范围。</p><p>26、你在工作中都写过什么脚本？</p><p>笔者回答：这个问题的回答别把话说得太大了，要结合实际情况来回答。写过mysql、redis、mongodb等数据库备份的脚本；服务器文件备份的脚本；日常代码发布的脚本；之前用nagios的时候写过一些nagios插件的脚本。</p><p>27、rsync+inotify是实现文件实时同步的，加什么参数才能实现实时同步，–delete参数又是什么意思？</p><p>笔者回答：rsync是远程同步工具、inotify是一种强大的异步文件系统系统监控机制。通过inotifywait 中的-m参数可以实现“始终保持事件监听状态”。rsync中的-delete参数是指“ 删除那些DST中SRC没有的文件”。</p><p>28、我想查看access.log中哪个IP访问最多？</p><p>笔者回答：awk ‘{print $1}’ access.log| sort | uniq -c |sort -rn -k 1  | head -1</p><p>上面的具体参数如果有不知道的，大家可以自行百度一下，这里不说参数这么细节的问题</p><p>29、在linux系统中，一般都会有swap内存，你觉得使用swap内存有什么好处，在什么情况下swap内存才会被使用？你觉得在生产环境中要不要用swap内存？</p><p>笔者回答：好处：在内存不够用的时候，将部分内存上的数据交换到swap空间上，以便让系统不会因为内存不够用而导致oom或者更致命的情况出现。</p><p>什么情况下会用swap：当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到swap空间中，等到那些程序要运行时，再从swap中恢复保存的数据到内存中。这样，系统总是在物理内存不够时，才进行swap交换。</p><p>30、怎么查看两台服务器之间的网络是不是正常的，服务器是禁ping的？</p><p>笔者回答：不能用ping，那可以用telnet对方服务器的端口、或者互相访问对方打开的服务。其它的测试方法笔者也没想到，要是哪位朋友有好的方法不访在下面留言讨论。</p><p>31、比如我访问百度网站，有什么方法可以跟踪经过了哪些网络节点？</p><p>笔者回答：这个太简单了吧，干运维必备的网络排查技能。用tracert命令就可以跟踪，主要是查询本机到另一个主机经过的路由跳数及数据延迟情况。然后你也可以把具体跟踪后输出的信息也说出来，你能说出来都是为你加分的。</p><p>32、如果你们公司的网站访问很慢，你会如何排查？</p><p>笔者回答：看到没有，又问到了这个问题，笔者在上一篇文章 2019年2月14号的面试中面试官也问到同样的问题。其实这种问题都没有具体答案，只是看你回答的内容与面试官契合度有多高，能不能说到他想要的点上，主要是看你排查问题的思路。我是这么说的：问清楚反应的人哪个服务应用或者页面调取哪个接口慢，叫他把页面或相关的URL发给你，首先，最直观的分析就是用浏览器按F12，看下是哪一块的内容过慢（DNS解析、网络加载、大图片、还是某个文件内容等），如果有，就对症下药去解决（图片慢就优化图片、网络慢就查看内网情况等）。其次，看后端服务的日志，其实大多数的问题看相关日志是最有效分析，最好用tail -f 跟踪一下日志，当然你也要点击测试来访问接口日志才会打出来。最后，排除sql，，找到sql去mysql执行一下，看看时间是否很久，如果很久，就要优化SQL问题了，expain一下SQL看看索引情况啥的，针对性优化。数据量太大的能分表就分表，能分库就分库。如果SQL没啥问题，那可能就是写的逻辑代码的问题了，一行行审代码，找到耗时的地方改造，优化逻辑。</p><p>33、我需要查看某个时间段的日志(比如access.log日志)，如何实现?</p><p>笔者回答：方法有很多种，比如我要看查的时间是2019年1月9号–1月10号的日志吧。</p><p>比如可以用sed命令，格式为：sed -n ‘/起始时间/,/结束时间/p’ 日志文件，如下：</p><p>sed -n ‘/09/Jan/2019/,/10/Jan/2019/p’ access.log</p><p>比如可以用grep，格式为：grep  -E ‘起始时间|结束时间’  日志文件，如下：</p><p>grep -E ‘09/Jan/2018|10/Jan/2018’ access.log</p><p>当然，你还可以结合cat、grep 、awk这些命令一起来使用都行</p>]]></content>
      
      
      <categories>
          
          <category> 运维相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>增删改</title>
      <link href="/2019/07/26/%E5%A2%9E%E5%88%A0%E6%94%B9/"/>
      <url>/2019/07/26/%E5%A2%9E%E5%88%A0%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建Connection连接</span></span><br><span class="line">    conn = connect(host=<span class="string">'localhost'</span>,port=<span class="number">3306</span>,database=<span class="string">'jing_dong'</span>,user=<span class="string">'root'</span>,password=<span class="string">'mysql'</span>,charset=<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="comment"># 获得Cursor对象</span></span><br><span class="line">    cs1 = conn.cursor()</span><br><span class="line">    <span class="comment"># 执行insert语句，并返回受影响的行数：添加一条数据</span></span><br><span class="line">    <span class="comment"># 增加</span></span><br><span class="line">    count = cs1.execute(<span class="string">'insert into goods_cates(name) values("硬盘")'</span>)</span><br><span class="line">    <span class="comment">#打印受影响的行数</span></span><br><span class="line">    print(count)</span><br><span class="line"></span><br><span class="line">    count = cs1.execute(<span class="string">'insert into goods_cates(name) values("光盘")'</span>)</span><br><span class="line">    print(count)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 更新</span></span><br><span class="line">    <span class="comment"># count = cs1.execute('update goods_cates set name="机械硬盘" where name="硬盘"')</span></span><br><span class="line">    <span class="comment"># # 删除</span></span><br><span class="line">    <span class="comment"># count = cs1.execute('delete from goods_cates where id=6')</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提交之前的操作，如果之前已经之执行过多次的execute，那么就都进行提交</span></span><br><span class="line">        conn.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭Cursor对象</span></span><br><span class="line">    cs1.close()</span><br><span class="line">    <span class="comment"># 关闭Connection对象</span></span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line">```    </span><br><span class="line">---</span><br><span class="line">查询一行数据</span><br><span class="line">---</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建Connection连接</span></span><br><span class="line">    conn = connect(host=<span class="string">'localhost'</span>,port=<span class="number">3306</span>,user=<span class="string">'root'</span>,password=<span class="string">'mysql'</span>,database=<span class="string">'jing_dong'</span>,charset=<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="comment"># 获得Cursor对象</span></span><br><span class="line">    cs1 = conn.cursor()</span><br><span class="line">    <span class="comment"># 执行select语句，并返回受影响的行数：查询一条数据</span></span><br><span class="line">    count = cs1.execute(<span class="string">'select id,name from goods where id&gt;=4'</span>)</span><br><span class="line">    <span class="comment"># 打印受影响的行数</span></span><br><span class="line">    print(<span class="string">"查询到%d条数据:"</span> % count)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">    <span class="comment"># 获取查询的结果</span></span><br><span class="line">    result = cs1.fetchone()</span><br><span class="line">    <span class="comment"># 打印查询的结果</span></span><br><span class="line">    print(result)</span><br><span class="line">    <span class="comment"># 获取查询的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭Cursor对象</span></span><br><span class="line">    cs1.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><hr><h2 id="查询多行数据"><a href="#查询多行数据" class="headerlink" title="查询多行数据"></a>查询多行数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建Connection连接</span></span><br><span class="line">    conn = connect(host=<span class="string">'localhost'</span>,port=<span class="number">3306</span>,user=<span class="string">'root'</span>,password=<span class="string">'mysql'</span>,database=<span class="string">'jing_dong'</span>,charset=<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="comment"># 获得Cursor对象</span></span><br><span class="line">    cs1 = conn.cursor()</span><br><span class="line">    <span class="comment"># 执行select语句，并返回受影响的行数：查询一条数据</span></span><br><span class="line">    count = cs1.execute(<span class="string">'select id,name from goods where id&gt;=4'</span>)</span><br><span class="line">    <span class="comment"># 打印受影响的行数</span></span><br><span class="line">    print(<span class="string">"查询到%d条数据:"</span> % count)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in range(count):</span></span><br><span class="line">    <span class="comment"># # 获取查询的结果</span></span><br><span class="line">    <span class="comment"># result = cs1.fetchone()</span></span><br><span class="line">    <span class="comment"># # 打印查询的结果</span></span><br><span class="line">    <span class="comment"># print(result)</span></span><br><span class="line">    <span class="comment"># # 获取查询的结果</span></span><br><span class="line"></span><br><span class="line">    result = cs1.fetchall()</span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭Cursor对象</span></span><br><span class="line">    cs1.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> pymsql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql 参数化</title>
      <link href="/2019/07/26/%E5%8F%82%E6%95%B0%E5%8C%96/"/>
      <url>/2019/07/26/%E5%8F%82%E6%95%B0%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>sql语句的参数化，可以有效防止sql注入<br>注意：此处不同于python的字符串格式化，全部使用%s占位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    find_name = input(<span class="string">"请输入物品名称："</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建Connection连接</span></span><br><span class="line">    conn = connect(host=<span class="string">'localhost'</span>,port=<span class="number">3306</span>,user=<span class="string">'root'</span>,password=<span class="string">'mysql'</span>,database=<span class="string">'jing_dong'</span>,charset=<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="comment"># 获得Cursor对象</span></span><br><span class="line">    cs1 = conn.cursor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># # 非安全的方式</span></span><br><span class="line">    <span class="comment"># # 输入 " or 1=1 or " (双引号也要输入)</span></span><br><span class="line">    <span class="comment"># sql = 'select * from goods where name="%s"' % find_name</span></span><br><span class="line">    <span class="comment"># print("""sql===&gt;%s&lt;====""" % sql)</span></span><br><span class="line">    <span class="comment"># # 执行select语句，并返回受影响的行数：查询所有数据</span></span><br><span class="line">    <span class="comment"># count = cs1.execute(sql)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 安全的方式</span></span><br><span class="line">    <span class="comment"># 构造参数列表</span></span><br><span class="line">    params = [find_name]</span><br><span class="line">    <span class="comment"># 执行select语句，并返回受影响的行数：查询所有数据</span></span><br><span class="line">    count = cs1.execute(<span class="string">'select * from goods where name=%s'</span>, params)</span><br><span class="line">    <span class="comment"># 注意：</span></span><br><span class="line">    <span class="comment"># 如果要是有多个参数，需要进行参数化</span></span><br><span class="line">    <span class="comment"># 那么params = [数值1, 数值2....]，此时sql语句中有多个%s即可</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印受影响的行数</span></span><br><span class="line">    print(count)</span><br><span class="line">    <span class="comment"># 获取查询的结果</span></span><br><span class="line">    <span class="comment"># result = cs1.fetchone()</span></span><br><span class="line">    result = cs1.fetchall()</span><br><span class="line">    <span class="comment"># 打印查询的结果</span></span><br><span class="line">    print(result)</span><br><span class="line">    <span class="comment"># 关闭Cursor对象</span></span><br><span class="line">    cs1.close()</span><br><span class="line">    <span class="comment"># 关闭Connection对象</span></span><br><span class="line">    conn.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10下使用Docker部署Mongodb</title>
      <link href="/2019/07/26/Win10%E4%B8%8B%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2mongo/"/>
      <url>/2019/07/26/Win10%E4%B8%8B%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2mongo/</url>
      
        <content type="html"><![CDATA[<p>在window下部署mongo，实在是有些坑。网上的很多教程是基于liunx，一般不会碰到很多麻烦。但在win10下就可能会出现问题。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注册账号，安装Docker</span><br><span class="line">获取Mongo镜像</span><br><span class="line">挂接数据目录启动容器</span><br><span class="line">启动容器</span><br></pre></td></tr></table></figure><h4 id="1、注册账号，安装Docker"><a href="#1、注册账号，安装Docker" class="headerlink" title="1、注册账号，安装Docker"></a>1、注册账号，安装Docker</h4><p>已经安装的可以忽略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">官网下载Docker： https://www.docker.com/get-started</span><br></pre></td></tr></table></figure><p>安装完成后，托盘下有个小鲸鱼。在cmd命令行下输入<code>docker version</code>，可以看到Docker的版本信息。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">D:\ISO</span><br><span class="line">λ docker version</span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           18.09.2</span><br><span class="line"> API version:       1.39</span><br><span class="line"> Go version:        go1.10.8</span><br><span class="line"> Git commit:        6247962</span><br><span class="line"> Built:             Sun Feb 10 04:12:31 2019</span><br><span class="line"> OS/Arch:           windows/amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          18.09.2</span><br><span class="line">  API version:      1.39 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.10.6</span><br><span class="line">  Git commit:       6247962</span><br><span class="line">  Built:            Sun Feb 10 04:13:06 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     false</span><br></pre></td></tr></table></figure><h4 id="2、获取Mongo镜像"><a href="#2、获取Mongo镜像" class="headerlink" title="2、获取Mongo镜像"></a>2、获取Mongo镜像</h4><p>使用搜索命令<code>docker search &lt;名称&gt;</code>可以找到一堆相关镜像。<code>OFFICIAL = [OK]</code>是官方的。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">D:\ISO</span><br><span class="line">λ docker search mongo</span><br><span class="line">NAME           DESCRIPTION          STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mongo          MongoDB document databases provide high avai…   <span class="number">6033</span>                [OK]</span><br><span class="line">mongo-express  Web-based MongoDB admin interface, written w…   <span class="number">487</span>                 [OK]</span><br><span class="line">tutum/mongodb  MongoDB Docker image – listens in port <span class="number">27017</span>…   <span class="number">226</span>                 [OK]</span><br><span class="line">bitnami/mongodb Bitnami MongoDB Docker Image                   <span class="number">92</span>                  [OK]</span><br><span class="line">mongoclient/mongoclient Official docker image for Mongoclient, featu…   <span class="number">70</span>         [OK]</span><br><span class="line">mongooseim/mongooseim   Small docker image for MongooseIM - robust a…   <span class="number">18</span></span><br><span class="line">frodenas/mongodb    A Docker Image for MongoDB                 <span class="number">17</span>                  [OK]</span><br><span class="line">cvallance/mongo-k8s-sidecar Kubernetes side car to setup and maintain a …   <span class="number">11</span>     [OK]</span><br><span class="line">centos/mongodb-<span class="number">32</span>-centos7           MongoDB NoSQL database server                   <span class="number">7</span></span><br><span class="line">centos/mongodb-<span class="number">26</span>-centos7           MongoDB NoSQL database server                   <span class="number">5</span></span><br><span class="line">istepanov/mongodump  Docker image with mongodump running as a cro…   <span class="number">5</span>             [OK]</span><br><span class="line">centos/mongodb-<span class="number">36</span>-centos7           MongoDB NoSQL database server    <span class="number">4</span></span><br><span class="line">eses/mongodb_exporter               mongodb exporter for prometheus  <span class="number">4</span>             [OK]</span><br><span class="line">webhippie/mongodb                   Docker images for MongoDB        <span class="number">4</span>             [OK]</span><br><span class="line">circleci/mongo                      CircleCI images for MongoDB      <span class="number">4</span>             [OK]</span><br><span class="line">arm64v8/mongo                       MongoDB document databases provide high avai…   <span class="number">4</span></span><br><span class="line">requilence/mongodb-backup           mongo backup container           <span class="number">3</span>             [OK]</span><br><span class="line">neowaylabs/mongodb-mms-agent   This Docker image with MongoDB Monitoring Ag…   <span class="number">2</span>   [OK]</span><br><span class="line">centos/mongodb-<span class="number">34</span>-centos7           MongoDB NoSQL database server                   <span class="number">2</span></span><br><span class="line">ekesken/mongo      docker image for mongo that is configurable …   <span class="number">1</span>               [OK]</span><br><span class="line">openshift/mongodb-<span class="number">24</span>-centos7        DEPRECATED: A Centos7 based MongoDB v2.<span class="number">4</span> ima…   <span class="number">1</span></span><br><span class="line">ansibleplaybookbundle/mongodb-apb   An APB to deploy MongoDB.        <span class="number">0</span>             [OK]</span><br><span class="line">martel/mongo-replica-ctrl  A dockerized controller for a Mongo db repli…   <span class="number">0</span>       [OK]</span><br><span class="line">andreasleicher/mongo-azure-backup a docker container to backup a mongodb using… <span class="number">0</span>  [OK]</span><br><span class="line">fuww/mongo-connector                mongo-connector + alpine + docker   <span class="number">0</span>          [OK]</span><br></pre></td></tr></table></figure><p>直接抓取最新版的Mongo，如果需要特定版本可以在后面加版本号。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;docker pull mongo</span><br><span class="line">抓取V <span class="number">3.2</span>版本的Mongo</span><br><span class="line">D:\&gt;docker pull mongo:<span class="number">3.2</span></span><br></pre></td></tr></table></figure><p>完成后可以看到本地镜像</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:\ISO</span><br><span class="line">λ docker image ls -a</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mongo               latest              <span class="number">785</span>c65f61380        <span class="number">12</span> days ago         <span class="number">412</span>MB</span><br><span class="line">ubuntu              latest              <span class="number">4</span>c108a37151f        <span class="number">3</span> weeks ago         <span class="number">64.2</span>MB</span><br></pre></td></tr></table></figure><h4 id="3、挂接数据目录启动容器"><a href="#3、挂接数据目录启动容器" class="headerlink" title="3、挂接数据目录启动容器"></a>3、挂接数据目录启动容器</h4><p>docker本身的镜像都属于只读，要保存数据就需要找个地方存。</p><p><strong>注意：</strong> 这个数据目录挂接在win10下是个坑</p><p>通常情况是建个目录，如（d:\dockerdata\mongo）使用 <code>-v</code> 命令参数进行连接，网上大部分的教程都是如此。实际会出现权限问题，无法正常启动。<strong>巨坑无比，浪费了好多时间</strong></p><p><strong>解决：</strong> 使用数据卷（Volume）解决，可以理解位虚拟磁盘。</p><h5 id="3-1、创建数据卷"><a href="#3-1、创建数据卷" class="headerlink" title="3.1、创建数据卷"></a>3.1、创建数据卷</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D:\ISO</span><br><span class="line">λ docker <span class="keyword">volume</span><span class="bash"> create --name mongodata</span></span><br><span class="line">mongodata</span><br><span class="line">D:\ISO</span><br><span class="line">λ docker <span class="keyword">volume</span><span class="bash"> ls</span></span><br><span class="line">DRIVER              <span class="keyword">VOLUME</span><span class="bash"> NAME</span></span><br><span class="line">local               mongodata</span><br></pre></td></tr></table></figure><p>可以看到已经创建了一个mongodata 的数据卷。</p><p><strong>单独删除：</strong> docker volume rm &lt;名称&gt;</p><h5 id="3-2、挂接运行mongo数据库"><a href="#3-2、挂接运行mongo数据库" class="headerlink" title="3.2、挂接运行mongo数据库"></a>3.2、挂接运行mongo数据库</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;docker <span class="keyword">run</span><span class="bash"> --name mongodb -v mongodata:/data/db -p 27017:27017 -d mongo:latest --auth</span></span><br><span class="line">a0585181d6102c6c4e1ebd7686fc8d08827632b5b279fb4eae7bf746e8ea49a9</span><br><span class="line"></span><br><span class="line">D:\&gt;docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                      NAMES</span><br><span class="line">a0585181d610        mongo:latest        <span class="string">"docker-entrypoint.s…"</span>   <span class="number">11</span> seconds ago      Up <span class="number">9</span> seconds        <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">27017</span>-&gt;<span class="number">27017</span>/tcp   mongodb</span><br></pre></td></tr></table></figure><p><strong>参数：</strong><br><strong>docker run</strong> 运行容器<br><strong>–name mongodb</strong> 运行容器的名称为mongodb<br><strong>-v mongodata:/data/db</strong> 挂接保存数据的位置，冒号前面是本机（mongodata），后面是虚拟机中的映射目录（/data/db）<br><strong>-p 27017:27017</strong> 映射端口，前面是本机端口，后面是docker内的端口<br><strong>–auth</strong> 授权访问</p><p><strong>命令：</strong> <code>docker ps</code></p><p>查看当前正在运行的容器对象，Mongo容器运行正常。</p><h4 id="4、授权创建账户"><a href="#4、授权创建账户" class="headerlink" title="4、授权创建账户"></a>4、授权创建账户</h4><blockquote><p><strong>命令：</strong> docker exec -it mongodb mongo admin</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;docker exec -it mongodb mongo admin</span><br><span class="line">MongoDB <span class="keyword">shell</span><span class="bash"> version v4.0.3</span></span><br><span class="line">connecting to: mongodb://<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">27017</span>/admin</span><br><span class="line">Implicit session: session &#123; <span class="string">"id"</span> : UUID(<span class="string">"85d97306-33e4-45d2-a8a5-ca85a2b46165"</span>) &#125;</span><br><span class="line">MongoDB server version: <span class="number">4.0</span>.<span class="number">3</span></span><br><span class="line">Welcome to the MongoDB <span class="keyword">shell</span>.<span class="bash"></span></span><br><span class="line"><span class="bash">For interactive <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span></span><br><span class="line">For more comprehensive documentation, see</span><br><span class="line">        http://docs.mongodb.org/</span><br><span class="line">Questions? Try the support group</span><br><span class="line">        http://groups.google.com/group/mongodb-<span class="keyword">user</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>创建账号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123; </span><br><span class="line">  user: &apos;root&apos;, </span><br><span class="line">  pwd: &apos;admin&apos;, </span><br><span class="line">  roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ] </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>授权：1 代表授权验证成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.auth(&quot;root&quot;,&quot;admin&quot;);</span><br></pre></td></tr></table></figure><p>创建一个新的数据库 blog_db，并授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建目标数据库（实际上切换即可）</span><br><span class="line">use blog_db</span><br><span class="line">创建目标数据库管理用户</span><br><span class="line">db.createUser(&#123; </span><br><span class="line">  user: &apos;blog&apos;, </span><br><span class="line">  pwd: &apos;blog123456&apos;, </span><br><span class="line">  roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;blog_db&quot; &#125; ] </span><br><span class="line">  &#125;);</span><br><span class="line">开启验证</span><br><span class="line">db.auth(&quot;blog&quot;,&quot;blog123456&quot;);</span><br></pre></td></tr></table></figure><h4 id="OK搞定"><a href="#OK搞定" class="headerlink" title="OK搞定"></a>OK搞定</h4><p>在win10下使用Docker有时有点坑，网上很多教程都是基于liunx的操作步骤。</p><p>现在碰到的主要有两个问题：</p><p>1、docker search 没有反应<br>2、系统没授权 Operation not permitted</p><h5 id="相关问题1：docker-search-没有反应"><a href="#相关问题1：docker-search-没有反应" class="headerlink" title="相关问题1：docker search 没有反应"></a>相关问题1：docker search 没有反应</h5><p>在使用docker中，正常都是设置自动启动Docker。在启动电脑后会出现pull无法拉取镜像</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:&gt;docker search mongo</span><br><span class="line">Error response from daemon: Get https://index.docker.io/v1/search?q=mongo&amp;n=25: dial tcp: lookup index.docker.io on 192.168.65.1:53: read udp 192.168.65.3:44014-&gt;192.168.65.1:53: i/o timeout</span><br></pre></td></tr></table></figure><blockquote><p><strong>解决方法：</strong><br>1、重新启动Docker，点托盘的小图标，选择重启菜单<br>2、重启无法解决，加国内镜像</p></blockquote><h5 id="增加国内镜像："><a href="#增加国内镜像：" class="headerlink" title="增加国内镜像："></a>增加国内镜像：</h5><ol><li>点击托盘小图标</li><li>选择 settings 菜单</li><li>在Settings对话框左侧选择 Daemon 选项</li><li>右侧 Registry mirrors 填入镜像地址</li><li>重启Docker</li></ol><h5 id="镜像地址"><a href="#镜像地址" class="headerlink" title="镜像地址"></a>镜像地址</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">随便加一个，都加也没问题</span><br><span class="line">https://docker.mirrors.ustc.edu.cn</span><br><span class="line">http://hub-mirror.c.163.com</span><br><span class="line">https://registry.docker-cn.com</span><br></pre></td></tr></table></figure><h5 id="相关问题2：-系统授权-Operation-not-permitted"><a href="#相关问题2：-系统授权-Operation-not-permitted" class="headerlink" title="相关问题2： 系统授权 Operation not permitted"></a>相关问题2： 系统授权 Operation not permitted</h5><p>使用常规的磁盘映射会出现的问题，如把数据文件映射到 <code>D:\docker\data\mongo</code> 目录下，使用 <code>docker ps</code> 就会发现没有容器在运行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\sunseeds&gt;docker <span class="keyword">run</span><span class="bash"> --name mongodb-server0 -v D:\docker\data\mongo:/data/db -p 27017:27017 -d mongo:latest --auth</span></span><br><span class="line"><span class="number">1</span>a1ec10c64716a8f2daee89ab7a18068559a0e7c2460741be0cc5cf82809812d</span><br><span class="line"></span><br><span class="line">C:\Users\sunseeds&gt;docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><p>使用下面命令<code>docker ps -a</code>，发现容器创建了，但未能正常运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>用 <code>docker logs mongodb-server0</code> 查看日志，启动失败无法创建数据文件的元凶，一堆密密麻麻的字里有一堆的<code>Operation not permitted</code>，最后来一句失败！</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">D:&gt;docker logs mongodb-server0</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">14.506</span>+<span class="number">0000</span> I CONTROL  [main] Automatically disabling TLS <span class="number">1.0</span>, to force-enable TLS <span class="number">1.0</span> specify --sslDisabledProtocols <span class="string">'none'</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">14.512</span>+<span class="number">0000</span> I CONTROL  [initandlisten] MongoDB starting : pid=<span class="number">1</span> port=<span class="number">27017</span> dbpath=/data/db <span class="number">64</span>-bit host=<span class="number">1</span>a1ec10c6471</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">14.512</span>+<span class="number">0000</span> I CONTROL  [initandlisten] db version v4.<span class="number">0.3</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">14.512</span>+<span class="number">0000</span> I CONTROL  [initandlisten] git version: <span class="number">7</span>ea530946fa7880364d88c8d8b6026bbc9ffa48c</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">14.512</span>+<span class="number">0000</span> I CONTROL  [initandlisten] OpenSSL version: OpenSSL <span class="number">1.0</span>.<span class="number">2</span>g  <span class="number">1</span> Mar <span class="number">2016</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">14.512</span>+<span class="number">0000</span> I CONTROL  [initandlisten] allocator: tcmalloc</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">14.512</span>+<span class="number">0000</span> I CONTROL  [initandlisten] modules: none</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">14.512</span>+<span class="number">0000</span> I CONTROL  [initandlisten] build environment:</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">14.512</span>+<span class="number">0000</span> I CONTROL  [initandlisten]     distmod: ubuntu1604</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">14.512</span>+<span class="number">0000</span> I CONTROL  [initandlisten]     distarch: x86_64</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">14.512</span>+<span class="number">0000</span> I CONTROL  [initandlisten]     target_arch: x86_64</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">14.512</span>+<span class="number">0000</span> I CONTROL  [initandlisten] options: &#123; net: &#123; bindIpAll: true &#125;, security: &#123; authorization: <span class="string">"enabled"</span> &#125; &#125;</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">14.525</span>+<span class="number">0000</span> I STORAGE  [initandlisten] wiredtiger_open config: create,cache_size=<span class="number">478</span>M,session_max=<span class="number">20000</span>,eviction=(threads_min=<span class="number">4</span>,threads_max=<span class="number">4</span>),config_base=false,statistics=(fast),log=(enabled=true,archive=true,path=journal,compressor=snappy),file_manager=(close_idle_time=<span class="number">100000</span>),statistics_log=(wait=<span class="number">0</span>),verbose=(recovery_progress),</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">15.354</span>+<span class="number">0000</span> E STORAGE  [initandlisten] WiredTiger error (<span class="number">1</span>) [<span class="number">1539784755</span>:<span class="number">354808</span>][<span class="number">1</span>:<span class="number">0</span>x7f0386d16a00], connection: __posix_open_file, <span class="number">715</span>: /data/db/WiredTiger.wt: handle-open: open: Operation not permitted Raw: [<span class="number">1539784755</span>:<span class="number">354808</span>][<span class="number">1</span>:<span class="number">0</span>x7f0386d16a00], connection: __posix_open_file, <span class="number">715</span>: /data/db/WiredTiger.wt: handle-open: open: Operation not permitted</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">15.405</span>+<span class="number">0000</span> E STORAGE  [initandlisten] WiredTiger error (<span class="number">17</span>) [<span class="number">1539784755</span>:<span class="number">405544</span>][<span class="number">1</span>:<span class="number">0</span>x7f0386d16a00], connection: __posix_open_file, <span class="number">715</span>: /data/db/WiredTiger.wt: handle-open: open: File exists Raw: [<span class="number">1539784755</span>:<span class="number">405544</span>][<span class="number">1</span>:<span class="number">0</span>x7f0386d16a00], connection: __posix_open_file, <span class="number">715</span>: /data/db/WiredTiger.wt: handle-open: open: File exists</span><br><span class="line">... ...</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">17</span>T13:<span class="number">59</span>:<span class="number">15.461</span>+<span class="number">0000</span> F -        [initandlisten]</span><br><span class="line"></span><br><span class="line">***aborting after fassert() failure</span><br></pre></td></tr></table></figure><blockquote><p><strong>解决：</strong> 创建Volume，进行连接</p></blockquote><p>Volume可以看作是Docker创建的一个虚拟磁盘。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker Mongo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh用法及命令</title>
      <link href="/2019/07/26/SSH%E7%99%BB%E5%BD%952/"/>
      <url>/2019/07/26/SSH%E7%99%BB%E5%BD%952/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是SSH？"><a href="#什么是SSH？" class="headerlink" title="什么是SSH？"></a>什么是SSH？</h4><p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。<br>SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。这里只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。</p><h5 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h5><p>SSH之所以能够保证安全，原因在于它采用了公钥加密。<br>整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。<br>这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。<br>可以设想，如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么SSH的安全机制就荡然无存了。这种风险就是著名的”中间人攻击”（Man-in-the-middle attack）。</p><h5 id="ssh的安装"><a href="#ssh的安装" class="headerlink" title="ssh的安装"></a>ssh的安装</h5><p>SSH分客户端openssh-client和openssh-server</p><p>如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudoapt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server。</p><p>Ubuntu缺省已经安装了ssh client。</p><h5 id="配置ssh"><a href="#配置ssh" class="headerlink" title="#配置ssh"></a>#配置ssh</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;\033[31;1m ******************************* \033[0m&quot;</span><br><span class="line">echo -e &quot;\033[31;1m ************安装和配置ssh************ \033[0m&quot;</span><br><span class="line">sudo apt-get install -y openssh-server 1&gt; /dev/null</span><br><span class="line">sudo sed -i &apos;s/UsePAM no/UsePAM yes/g&apos; /etc/ssh/sshd_config</span><br><span class="line">sudo sed -i &apos;8a /etc/init.d/ssh start&apos; /etc/profile</span><br><span class="line">sudo /etc/init.d/ssh start</span><br><span class="line">ps -e | grep ssh</span><br><span class="line"></span><br><span class="line">echo -e &quot;\033[31;1m ssh授权 \033[0m&quot;</span><br><span class="line">cd ~/.ssh/</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">cat ./id_rsa.pub &gt;&gt; ./authorized_keys</span><br><span class="line"></span><br><span class="line">$ ps -e|grep ssh</span><br><span class="line"> 2151 ?        00:00:00 ssh-agent</span><br><span class="line"></span><br><span class="line"> 5313 ?        00:00:00 sshd</span><br><span class="line"></span><br><span class="line">ssh-agent表示ssh-client启动，sshd表示ssh-server启动了。</span><br><span class="line"></span><br><span class="line">如果缺少sshd，说明ssh服务没有启动或者没有安装。</span><br></pre></td></tr></table></figure><h3 id="SSH基本用法"><a href="#SSH基本用法" class="headerlink" title="SSH基本用法"></a>SSH基本用法</h3><h4 id="SSH远程登录"><a href="#SSH远程登录" class="headerlink" title="SSH远程登录"></a>SSH远程登录</h4><h5 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h5><p>假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host  如：ssh pika@192.168.0.111</span><br></pre></td></tr></table></figure><p>如果本地用户名与远程用户名一致，登录时可以省略用户名。</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh host</span><br></pre></td></tr></table></figure><p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p 2222 user@host</span><br></pre></td></tr></table></figure></code></pre><p>上面这条命令表示，ssh直接连接远程主机的2222端口。<br>如果你是第一次登录对方主机，系统会出现下面的提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host</span><br><span class="line">    　　The authenticity of host <span class="string">'host (12.18.429.21)'</span> can<span class="string">'t be established.</span></span><br><span class="line"><span class="string">    　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span></span><br><span class="line"><span class="string">    　　Are you sure you want to continue connecting (yes/no)?</span></span><br></pre></td></tr></table></figure><p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？<br>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。<br>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。<br>假定经过风险衡量以后，用户决定接受这个远程主机的公钥。<br>    　　Are you sure you want to continue connecting (yes/no)? yes<br>系统会出现一句提示，表示host主机已经得到认可。<br>    　　Warning: Permanently added ‘host,12.18.429.21’ (RSA) to the list of known hosts.<br>然后，会要求输入密码。<br>    　　Password: (enter password)<br>如果密码正确，就可以登录了。<br>当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p><h5 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h5><p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。<br>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。<br>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：</p><pre><code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure></code></pre><p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。<br>运行结束以后，在$HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。<br>这时再输入下面的命令，将公钥传送到远程主机host上面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-copy-id user@host</span><br></pre></td></tr></table></figure><p>好了，从此你再登录，就不需要输入密码了。<br>如果还是不行，就打开远程主机的/etc/ssh/sshd_config这个文件，检查下面几行前面”#”注释是否取掉。<br>    　　RSAAuthentication yes<br>    　　PubkeyAuthentication yes<br>    　　AuthorizedKeysFile .ssh/authorized_keys<br>然后，重启远程主机的ssh服务。</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ubuntu系统</span><br><span class="line">   service ssh restart</span><br><span class="line">// debian系统</span><br><span class="line">   /etc/init.d/ssh restart</span><br></pre></td></tr></table></figure></code></pre><p><strong>authorized_keys文件</strong></p><p>远程主机将用户的公钥，保存在登录后的用户主目录的$HOME/.ssh/authorized_keys文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。<br>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host <span class="string">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>这条命令由多个语句组成，依次分解开来看：（1）”$ ssh user@host”，表示登录远程主机；（2）单引号中的mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys，表示登录后在远程shell上执行的命令：（3）”$ mkdir -p .ssh”的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；（4）’cat &gt;&gt; .ssh/authorized_keys’ &lt; <del>/.ssh/id_rsa.pub的作用是，将本地的公钥文件</del>/.ssh/id_rsa.pub，重定向追加到远程文件authorized_keys的末尾。<br>写入authorized_keys文件后，公钥登录的设置就完成了。</p><h6 id="SSH原理与运用（一）：远程登录"><a href="#SSH原理与运用（一）：远程登录" class="headerlink" title="[SSH原理与运用（一）：远程登录]"></a>[SSH原理与运用（一）：远程登录]</h6><h5 id="使用ssh在远程后台不中断地跑程序"><a href="#使用ssh在远程后台不中断地跑程序" class="headerlink" title="使用ssh在远程后台不中断地跑程序"></a>使用ssh在远程后台不中断地跑程序</h5><p>Linux关闭ssh（关闭终端等）后运行的程序或者服务自动停止，如python3 a.py &amp;。</p><p>解决：使用nohup命令让程序在关闭窗口（切换SSH连接）的时候程序还能继续在后台运行。</p><p>nohup python3 a.py &amp;</p><h6 id="linux进程管理与SELinux"><a href="#linux进程管理与SELinux" class="headerlink" title="[linux进程管理与SELinux]"></a>[linux进程管理与SELinux]</h6><h5 id="SSH远程操作"><a href="#SSH远程操作" class="headerlink" title="SSH远程操作"></a>SSH远程操作</h5><h5 id="SSH数据传输"><a href="#SSH数据传输" class="headerlink" title="SSH数据传输"></a>SSH数据传输</h5><p>SSH不仅可以用于远程主机登录，还可以直接在远程主机上执行操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host <span class="string">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。<br>这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道，因此很多事情都可以通过SSH来完成。<br>下面看几个例子。<br>【例1】<br>将$HOME/src/目录下面的所有文件，复制到远程主机的$HOME/src/目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> &amp;&amp; tar czv src | ssh user@host <span class="string">'tar xz'</span></span><br></pre></td></tr></table></figure><p>【例2】<br>将远程主机$HOME/src/目录下面的所有文件，复制到用户的当前目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host <span class="string">'tar cz src'</span> | tar xzv</span><br></pre></td></tr></table></figure><p>【例3】<br>查看远程主机是否运行进程httpd。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host <span class="string">'ps ax | grep [h]ttpd'</span></span><br></pre></td></tr></table></figure><p>lz建议使用scp进行远程copy：</p><h5 id="scp-跨机远程拷贝"><a href="#scp-跨机远程拷贝" class="headerlink" title="scp 跨机远程拷贝"></a>scp 跨机远程拷贝</h5><p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。两台主机之间复制文件必需得同时有两台主机的复制执行帐号和操作权限。</p><h5 id="scp命令参数"><a href="#scp命令参数" class="headerlink" title="scp命令参数"></a>scp命令参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-1 强制scp命令使用协议ssh1</span><br><span class="line">-2 强制scp命令使用协议ssh2</span><br><span class="line">-4 强制scp命令只使用IPv4寻址</span><br><span class="line">-6 强制scp命令只使用IPv6寻址</span><br><span class="line">-B 使用批处理模式（传输过程中不询问传输口令或短语）</span><br><span class="line">-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</span><br><span class="line">-p 留原文件的修改时间，访问时间和访问权限。</span><br><span class="line">-q 不显示传输进度条。</span><br><span class="line">-r 递归复制整个目录。</span><br><span class="line">-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</span><br><span class="line">-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</span><br><span class="line">-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。</span><br><span class="line">-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</span><br><span class="line">-l limit 限定用户所能使用的带宽，以Kbit/s为单位。</span><br><span class="line">-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，</span><br><span class="line">-P port 注意是大写的P, port是指定数据传输用到的端口号</span><br><span class="line">-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</span><br></pre></td></tr></table></figure><h5 id="scp一般有六种使用方法"><a href="#scp一般有六种使用方法" class="headerlink" title="scp一般有六种使用方法"></a>scp一般有六种使用方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">本地复制远程文件：（把远程的文件复制到本地）</span><br><span class="line">scp root@www.test.com:/val/test/test.tar.gz /val/test/test.tar.gz</span><br><span class="line">远程复制本地文件：（把本地的文件复制到远程主机上）</span><br><span class="line">scp /val/test.tar.gz root@www.test.com:/val/test.tar.gz</span><br><span class="line">本地复制远程目录：（把远程的目录复制到本地）</span><br><span class="line">scp -r root@www.test.com:/val/test/ /val/test/</span><br><span class="line">远程复制本地目录：（把本地的目录复制到远程主机上）</span><br><span class="line">scp -r ./ubuntu_env/ root@192.168.0.111:/home/pipi</span><br><span class="line">pika:/media/pika/files/machine_learning/datasets$scp -r </span><br><span class="line">SocialNetworks/ piting@192.168.0.172:/media/data/pipi/datasets</span><br><span class="line">本地复制远程文件到指定目录：（把远程的文件复制到本地）</span><br><span class="line">scp root@www.test.com:/val/test/test.tar.gz /val/test/</span><br><span class="line">远程复制本地文件到指定目录：（把本地的文件复制到远程主机上）</span><br><span class="line">scp /val/test.tar.gz root@www.test.com:/val/</span><br><span class="line"></span><br><span class="line">ps: scp复制文件时只指定服务器地址不加路径默认复制到哪里???</span><br><span class="line"></span><br><span class="line">[12个scp传输文件的命令栗子]</span><br><span class="line"></span><br><span class="line">[scp 跨机远程拷贝]</span><br></pre></td></tr></table></figure><h5 id="SSH端口操作"><a href="#SSH端口操作" class="headerlink" title="SSH端口操作"></a>SSH端口操作</h5><h5 id="绑定本地端口"><a href="#绑定本地端口" class="headerlink" title="绑定本地端口"></a>绑定本地端口</h5><p>既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。<br>假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -D 8080 user@host</span><br></pre></td></tr></table></figure><p>SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。</p><h5 id="本地端口转发"><a href="#本地端口转发" class="headerlink" title="本地端口转发"></a>本地端口转发</h5><p>有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的”端口转发”。为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding）。<br>假定host1是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过host3，将host1连上host2。<br>我们在host1执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -L 2121:host2:21 host3</span><br></pre></td></tr></table></figure><p>命令中的L参数一共接受三个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。<br>这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ftp localhost:2121</span><br></pre></td></tr></table></figure><p>“本地端口转发”使得host1和host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为”SSH隧道”。<br>下面是一个比较有趣的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -L 5900:localhost:5900 host3</span><br></pre></td></tr></table></figure><p>它表示将本机的5900端口绑定host3的5900端口（这里的localhost指的是host3，因为目标主机是相对host3而言的）。<br>另一个例子是通过host3的端口转发，ssh登录host2。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -L 9001:host2:22 host3</span><br></pre></td></tr></table></figure><p>这时，只要ssh登录本机的9001端口，就相当于登录host2了。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p 9001 localhost</span><br></pre></td></tr></table></figure><p>上面的-p参数表示指定登录端口。</p><p>出错处理：ssh: Could not resolve hostname 192.168.<em>.</em>:***: Name or service not known</p><p>解决：指定端口不能直接使用ip:端口号，使用-p参数来解决就可以了。</p><h5 id="远程端口转发"><a href="#远程端口转发" class="headerlink" title="远程端口转发"></a>远程端口转发</h5><p>既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。<br>还是接着看上面那个例子，host1与host2之间无法连通，必须借助host3转发。但是，特殊情况出现了，host3是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的host1连不上内网的host3。这时，”本地端口转发”就不能用了，怎么办？<br>解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。<br>我们在host3执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -R 2121:host2:21 host1</span><br></pre></td></tr></table></figure><p>R参数也是接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。<br>绑定之后，我们在host1就可以连接host2了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ftp localhost:2121</span><br></pre></td></tr></table></figure><p>这里必须指出，”远程端口转发”的前提条件是，host1和host3两台主机都有sshD和ssh客户端。</p><h5 id="SSH的其他参数"><a href="#SSH的其他参数" class="headerlink" title="SSH的其他参数"></a>SSH的其他参数</h5><p>SSH还有一些别的参数，也值得介绍。<br>N参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -NT -D 8080 host</span><br></pre></td></tr></table></figure><p>f参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -f -D 8080 host</span><br></pre></td></tr></table></figure><p>要关闭这个后台连接，就只有用kill命令去杀掉进程。</p><h6 id="SSH原理与运用（二）：远程操作与端口转发"><a href="#SSH原理与运用（二）：远程操作与端口转发" class="headerlink" title="[SSH原理与运用（二）：远程操作与端口转发]"></a>[SSH原理与运用（二）：远程操作与端口转发]</h6><h6 id="ref-Ubuntu环境下SSH的安装及使用"><a href="#ref-Ubuntu环境下SSH的安装及使用" class="headerlink" title="ref: [Ubuntu环境下SSH的安装及使用]"></a>ref: [Ubuntu环境下SSH的安装及使用]</h6><h6 id="25个必须记住的SSH命令"><a href="#25个必须记住的SSH命令" class="headerlink" title="[25个必须记住的SSH命令]*"></a>[25个必须记住的SSH命令]*</h6><h6 id="Linux-下-SSH-命令实例指南"><a href="#Linux-下-SSH-命令实例指南" class="headerlink" title="[Linux 下 SSH 命令实例指南]*"></a>[Linux 下 SSH 命令实例指南]*</h6><h6 id="数字签名是什么？"><a href="#数字签名是什么？" class="headerlink" title="[数字签名是什么？]"></a>[数字签名是什么？]</h6><p>[　　* SSH, The Secure Shell: The Definitive Guide: 2.4. Authentication by Cryptographic Key, O’reilly</p><ul><li>SSH, The Secure Shell: The Definitive Guide: 9.2. Port Forwarding, O’reilly</li><li>Shebang: Tips for Remote Unix Work (SSH, screen, and VNC)</li><li>brihatch: SSH Host Key Protection</li><li>brihatch: SSH User Identities</li><li>IBM developerWorks: 实战 SSH 端口转发</li><li>Jianing YANG：ssh隧道技术简介</li><li>WikiBooks: Internet Technologies/SSH</li><li>Buddhika Chamith: SSH Tunneling Explained</li></ul><h5 id><a href="#" class="headerlink" title="]"></a>]</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原文来源：https://blog.csdn.net/pipisorry/article/details/52269785</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SSH </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH  Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本之查看磁盘目录、删除用户脚本</title>
      <link href="/2019/07/26/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
      <url>/2019/07/26/Shell%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/usr/bin/env bash</span><br><span class="line"><span class="meta">#</span> 来源: https://blog.csdn.net/qianghaohao/article/details/80379118 </span><br><span class="line"><span class="meta">#</span> 服务器线程数达到 2500 以上时 dump 线程数最多的 java 进程的线程及内存</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">source ~/.bashrc</span><br><span class="line">cur_thread_num=`ps -efL | wc -l`</span><br><span class="line">if [ $cur_thread_num -le 2500 ]; then</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cur_date=`date +"%Y-%m-%d_%H-%M-%S"`</span><br><span class="line">cd ./dumpfile</span><br><span class="line"><span class="meta">#</span> 服务器当前线程 dump 到文件:按照线程数由大到小排序显示</span><br><span class="line">ps -efL --sort -nlwp &gt; server_thread_dump_$cur_date</span><br><span class="line"><span class="meta">#</span> dump 线程数最多的 jvm 的线程及内存</span><br><span class="line">most_thread_num_pid=`cat server_thread_dump_$cur_date | sed -n '2p' | awk '&#123;print $2&#125;'`</span><br><span class="line">nohup jstack -l $most_thread_num_pid &gt; java_app_thread_dump_$&#123;cur_date&#125;_pid_$&#123;most_thread_num_pid&#125; &amp;</span><br><span class="line">nohup jmap -dump:format=b,file=java_app_mem_dump_$&#123;cur_date&#125;_pid_$&#123;most_thread_num_pid&#125; $most_thread_num_pid &amp;</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h4 id="查看磁盘目录使用情况"><a href="#查看磁盘目录使用情况" class="headerlink" title="查看磁盘目录使用情况"></a><strong>查看磁盘目录使用情况</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Big_Users - find big disk space users in various directories</span><br><span class="line"><span class="meta">#</span>############################################################</span><br><span class="line"><span class="meta">#</span>Parameters for script</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">CHECK_DIRECTORIES="/var/log /home" #directories to check</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>######################## Main Script #######################</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">DATE=$(date '+%m%d%y')             #Date for report file</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">exec &gt; disk_space_$DATE.rpt         #Make report file Std Output</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">echo "Top Ten Disk Space Usage"     #Report header for while report</span><br><span class="line">echo "for $CHECK_DIRECTORIES Directories"</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">for DIR_CHECK in $CHECK_DIRECTORIES       #loop to du directories</span><br><span class="line">do</span><br><span class="line">echo ""</span><br><span class="line">echo "The $DIR_CHECK Directory:"#Title header for each directory</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>Creating a listing of top ten disk space users</span><br><span class="line">du -S $DIR_CHECK 2&gt;/dev/null |</span><br><span class="line">sort -rn |</span><br><span class="line">sed '&#123;11,$D; =&#125;' |</span><br><span class="line">sed 'N; s/\n/ /' | </span><br><span class="line">gawk '&#123;printf $1 ":" "\t" $2 "\t" $3 "\n"&#125;'</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">done#End of for loop for du directories</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><h4 id="删除用户脚本"><a href="#删除用户脚本" class="headerlink" title="删除用户脚本"></a>删除用户脚本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Delete_User - Automates the 4 steps to remove an account</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>################################################################</span><br><span class="line"><span class="meta">#</span> </span><br><span class="line"><span class="meta">#</span> Define Functions</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>################################################################</span><br><span class="line">function get_answer &#123;</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">unset ANSWER</span><br><span class="line">ASK_COUNT=0</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">while [ -z "$ANSWER" ] # while no answer is given, keep asking</span><br><span class="line">do</span><br><span class="line">ASK_COUNT=$[ $ASK_COUNT + 1 ]</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">case $ASK_COUNT in# If user gives no answer in time allowed</span><br><span class="line">2)</span><br><span class="line">echo </span><br><span class="line">echo "Please answer the question."</span><br><span class="line">echo</span><br><span class="line">;;</span><br><span class="line">3)</span><br><span class="line">echo </span><br><span class="line">echo "One last try... please answer the question."</span><br><span class="line">echo</span><br><span class="line">;;</span><br><span class="line">4)</span><br><span class="line">echo </span><br><span class="line">echo "Since you refuse to answer the question..."</span><br><span class="line">echo "exiting program."</span><br><span class="line">echo</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">exit</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">echo</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">if [ -n "$LINE2" ]</span><br><span class="line">then</span><br><span class="line">echo $LINE1# Print 2 lines</span><br><span class="line">echo -e $LINE2" \c"</span><br><span class="line">else# Print 1 line</span><br><span class="line">echo -e $LINE1" \c"</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Allow 60 seconds to answer before time-out</span><br><span class="line">read -t 60 ANSWER</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Do a little variable clean-up</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">unset LINE1</span><br><span class="line">unset LINE2</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">&#125;    #end of get_answer function</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>################################################################</span><br><span class="line">function process_answer &#123;</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">case $ANSWER in</span><br><span class="line">y|Y|YES|yes|yEs|yeS|YEs|yES)</span><br><span class="line"><span class="meta">#</span> If user answers "yes".do nothing.</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line"><span class="meta">#</span> If user answers anything but "yes", exit script</span><br><span class="line">echo</span><br><span class="line">echo $EXIT_LINE1</span><br><span class="line">echo $EXIT_LINE2</span><br><span class="line">echo</span><br><span class="line">exit</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Do a little variable clean-up</span><br><span class="line">unset EXIT_LINE1</span><br><span class="line">unset EXIT_LINE2</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">&#125; #End of process_answer function</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>###############################################################</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> End of Function Definitions</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>############## Main Script #################################</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Get name of User Account to check</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">echo "Step #1 - Determine User Account name to delete "</span><br><span class="line">echo</span><br><span class="line">LINE1="Please enter the username of the user"</span><br><span class="line">LINE2="account you wish to delete from system:"</span><br><span class="line">get_answer</span><br><span class="line">USER_ACCOUNT=$ANSWER</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Double check with script user that this is the correct User Account</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">LINE1="Is $USER_ACCOUNT the user account"</span><br><span class="line">LINE2="you wish to delete from the system?[ y/n ]:"</span><br><span class="line">get_answer</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>###########################################################</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Check that USER_ACCOUNT is really an account on the system</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">USER_ACCOUNT_RECORD=$(cat /etc/passwd | grep -w $USER_ACCOUNT)</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">if [ $? -eq 1 ]# If the account is not found, exit script</span><br><span class="line">then</span><br><span class="line">echo </span><br><span class="line">echo "Account, $USER_ACCOUNT, not found."</span><br><span class="line">echo "Leaving the script..."</span><br><span class="line">echo</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">echo</span><br><span class="line">echo "I found this record:"</span><br><span class="line">echo $USER_ACCOUNT_RECORD</span><br><span class="line">echo</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">LINE1="Is this the correct User Account?[y/n]:"</span><br><span class="line">get_answer</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Call process_answer function:</span><br><span class="line"><span class="meta">#</span>if user answers anything but "yes", exit script</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">EXIT_LINE1="Because the account, $USER_ACCOUNT, is not "</span><br><span class="line">EXIT_LINE2="the one you wish to delete, we are leaving the script..."</span><br><span class="line">process_anser</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span>#############################################################</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Search for any running processes that belong to the User Account</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">echo</span><br><span class="line">echo "Step #2 - Find process on system belonging to user account"</span><br><span class="line">echo</span><br><span class="line">echo "$USER_ACCOUNT has the following processes running: "</span><br><span class="line">echo</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">ps -u $USER_ACCOUNT      #List the processes running</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">case $? in</span><br><span class="line">1)# No processes running for this User Account</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">echo "There are no processes for this account currently running."</span><br><span class="line">echo</span><br><span class="line">;;</span><br><span class="line">0)# Processes running for this User Account.</span><br><span class="line"><span class="meta">#</span> Ask Script User if wants us to kill the processes.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">unset ANSWER# I think this line is not needed</span><br><span class="line">LINE1="Would you like me to kill the process(es)? [y/n]:"</span><br><span class="line">get_answer</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">case $ANSWER in</span><br><span class="line">y|Y|YES|yes|Yes|yEs|yeS|YEs|yES)    # if user answer "yes",</span><br><span class="line"><span class="meta">#</span>kill User Account processes</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">echo </span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Clean-up temp file upon signals</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">trap "rm $USER_ACCOUNT_Running_Process.rpt" SIGTERM SIGINT SIGQUIT</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> List user processes running</span><br><span class="line">ps -u $USER_ACCOUNT &gt; $USER_ACCOUNT_Running_Process.rpt</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">exec &lt; $USER_ACCOUNT_Running_Process.rpt# Make report Std Input</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">read USER_PROCESS_REC# First record will be blank</span><br><span class="line">read USER_PROCESS_REC</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">while [ $? -eq 0 ]</span><br><span class="line">do</span><br><span class="line"><span class="meta">#</span> obtain PID</span><br><span class="line">USER_PID=$(echo $USER_PROCESS_REC | cut -d " " -f1 )</span><br><span class="line">kill -9 $USER_PID</span><br><span class="line">echo "Killed process $USER_PID"</span><br><span class="line">read USER_PROCESS_REC</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">echo</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">rm $USER_ACCOUNT_Running_Process.rpt# Remove temp report</span><br><span class="line">;;</span><br><span class="line">*) # If user answers anything but "yes", do not kill.</span><br><span class="line">echo</span><br><span class="line">echo "Will not kill the process(es)."</span><br><span class="line">echo</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"><span class="meta">#</span>##################################################################################</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Create a report of all files owned by User Account</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">echo</span><br><span class="line">echo "Step #3 - Find files on system belonging to user account"</span><br><span class="line">echo</span><br><span class="line">echo "Creating a report of all files owned by $USER_ACCOUNT."</span><br><span class="line">echo</span><br><span class="line">echo "It is recommended that you backup/archive these files."</span><br><span class="line">echo "and then do one of two things:"</span><br><span class="line">echo " 1) Delete the files"</span><br><span class="line">echo " 2) Change the files' ownership to a current user account."</span><br><span class="line">echo</span><br><span class="line">echo "Please wait. This may take a while..."</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">REPORT_DATE=`date +%y%m%d`</span><br><span class="line">REPORT_FILE=$USER_ACCOUNT"_Files_"$REPORT_DATE".rpt"</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">find / -user $USER_ACCOUNT &gt; $REPORT_FILE 2&gt;/dev/null</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">echo</span><br><span class="line">echo "Report is complete."</span><br><span class="line">echo "Name of report:$REPORT_FILE"</span><br><span class="line">echo "Location of report:     `pwd`"</span><br><span class="line">echo</span><br><span class="line"><span class="meta">#</span>###############################################################</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Remove User Account</span><br><span class="line">echo</span><br><span class="line">echo "Step #4 - Remove user account"</span><br><span class="line">echo</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">LINE1="Do you wish to remove $USER_ACCOUNT's account from system? [y/n]:"</span><br><span class="line">get_answer</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Cass process_answer function:</span><br><span class="line"><span class="meta">#</span>if user answers anything but "yes", exit script</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">EXIT_LINE1="Since you do not wish to remove the user account."</span><br><span class="line">EXIT_LINE2="$USER_ACCOUNT at this time, exiting the script..."</span><br><span class="line">process_answer</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">userdel $USER_ACCOUNT# delete user account</span><br><span class="line">echo</span><br><span class="line">echo "User account, $USER_ACCOUNT, has been removed"</span><br><span class="line">echo</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell Linux 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell命令运算</title>
      <link href="/2019/07/26/shell%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E8%BF%90%E7%AE%97/"/>
      <url>/2019/07/26/shell%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h5 id="exit-命令"><a href="#exit-命令" class="headerlink" title="exit 命令"></a>exit 命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>退出状态码，最大为255，超过则进行模运算</span><br><span class="line"><span class="meta">#</span>testing the exit status</span><br><span class="line">var1=10</span><br><span class="line">var2=20</span><br><span class="line">var3=$[ $var1 + $var2]</span><br><span class="line">echo The answer is $var3</span><br><span class="line">exit 5</span><br></pre></td></tr></table></figure><h5 id="使用expr执行数学运算"><a href="#使用expr执行数学运算" class="headerlink" title="使用expr执行数学运算"></a><strong>使用expr执行数学运算</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>An example of using the expr command</span><br><span class="line"></span><br><span class="line">var1=10</span><br><span class="line">var2=20</span><br><span class="line">var3=`expr $var2 / $var1`</span><br><span class="line">echo "The result is $var3"</span><br></pre></td></tr></table></figure><h5 id="使用内联重定向计算表达式"><a href="#使用内联重定向计算表达式" class="headerlink" title="使用内联重定向计算表达式"></a><strong>使用内联重定向计算表达式</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">var1=10.45</span><br><span class="line">var2=43.67</span><br><span class="line">var3=33.2</span><br><span class="line">var4=71</span><br><span class="line"></span><br><span class="line">var5=`bc &lt;&lt;EOF</span><br><span class="line">scale=4</span><br><span class="line">a1 = $var1 * $var2</span><br><span class="line">b1 = $var3 * $var4</span><br><span class="line">a1 + b1</span><br><span class="line">EOF</span><br><span class="line">`</span><br><span class="line">echo The final answer for this mess is $var5</span><br></pre></td></tr></table></figure><h5 id="使用方括号执行数学运算"><a href="#使用方括号执行数学运算" class="headerlink" title="使用方括号执行数学运算"></a><strong>使用方括号执行数学运算</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"></span><br><span class="line">var1=10</span><br><span class="line">var2=50</span><br><span class="line">var3=45</span><br><span class="line">var4=$[$var1 * ($var2 - $var3)]</span><br><span class="line">echo 'The final result is '$var4</span><br></pre></td></tr></table></figure><h5 id="使用自定义变量"><a href="#使用自定义变量" class="headerlink" title="使用自定义变量"></a><strong>使用自定义变量</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>testing variables</span><br><span class="line"></span><br><span class="line">days=10</span><br><span class="line">guest="Katie"</span><br><span class="line">echo "$guest logged in $days days age"</span><br><span class="line">guest="Katie2"</span><br><span class="line">days=5</span><br><span class="line">echo "$guest logged in $days days age"</span><br></pre></td></tr></table></figure><h5 id="反引号的使用"><a href="#反引号的使用" class="headerlink" title="反引号的使用"></a><strong>反引号的使用</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>using the backtick character  会把反引号里面当作一条命令来执行</span><br><span class="line"></span><br><span class="line">testing=`date`</span><br><span class="line">echo "The date and time are:$testing"</span><br></pre></td></tr></table></figure><h5 id="在脚本中使用bc"><a href="#在脚本中使用bc" class="headerlink" title="在脚本中使用bc"></a><strong>在脚本中使用bc</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">var1=100</span><br><span class="line">var2=45</span><br><span class="line">var3=`echo "scale=4; $var1 / $var2" | bc`</span><br><span class="line">echo The answer for this is $var3</span><br></pre></td></tr></table></figure><h5 id="显示时间和登录者"><a href="#显示时间和登录者" class="headerlink" title="显示时间和登录者"></a><strong>显示时间和登录者</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>This script displays the date and who's logged on</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>如果想在同一行显示</span><br><span class="line"><span class="meta">#</span>echo -n -e 'The time is:\n\n'</span><br><span class="line">echo The time is:</span><br><span class="line">date</span><br><span class="line">echo The one who has been logged is:</span><br><span class="line">who</span><br></pre></td></tr></table></figure><h5 id="显示系统变量和转义字符"><a href="#显示系统变量和转义字符" class="headerlink" title="显示系统变量和转义字符"></a><strong>显示系统变量和转义字符</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>display user information from system</span><br><span class="line"></span><br><span class="line">echo "User info fro userId:$USER"</span><br><span class="line">echo UID:$UID</span><br><span class="line">echo HOME:$HOME</span><br><span class="line"><span class="meta">#</span>换行</span><br><span class="line">echo -e '\n'      </span><br><span class="line">echo 'The cost of the item is \$15'</span><br></pre></td></tr></table></figure><h5 id="通过反引号获得当前日期并生成唯一文件名"><a href="#通过反引号获得当前日期并生成唯一文件名" class="headerlink" title="通过反引号获得当前日期并生成唯一文件名"></a><strong>通过反引号获得当前日期并生成唯一文件名</strong></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line"><span class="meta">#</span>copy the /usr/bin directory listing to a log file</span><br><span class="line"></span><br><span class="line">today=`date +%y%m%d`</span><br><span class="line">ls /usr/bin -al &gt; log.$today</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell Linux 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOs7 下的Python3 的安装</title>
      <link href="/2019/07/26/CentOs7%E4%B8%8BPython3-%E7%9B%B8%E5%85%B3%E5%AE%89%E8%A3%85/"/>
      <url>/2019/07/26/CentOs7%E4%B8%8BPython3-%E7%9B%B8%E5%85%B3%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos7下python3的安装，virtualenv、virtualenvwrapper虚拟独立环境管理工具"><a href="#Centos7下python3的安装，virtualenv、virtualenvwrapper虚拟独立环境管理工具" class="headerlink" title="Centos7下python3的安装，virtualenv、virtualenvwrapper虚拟独立环境管理工具"></a>Centos7下python3的安装，virtualenv、virtualenvwrapper虚拟独立环境管理工具</h1><hr><p>安装准备工具:</p><p># yum groupinstall “Developmenttools”</p><p># yum install zlib-devel bzip2-developenssl-devel ncurses-devel sqlite-devel readline-develtk-devel gdbm-develdb4-devel libpcap-devel xz-devel</p><p> ————————————-安装python—————————————</p><p>下载python3源码</p><p>wget <a href="https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tar.xz" target="_blank" rel="noopener">wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tar.xz </a></p><p>解压：Python-3.6.5.tar.xz</p><p>解压后新建文件夹将Python-3.6.5放在/usr/local/python3下</p><p>1.# mkdir python3</p><p>2.# mv Python-3.6.5 python3</p><p>3.# cd python3/Python-3.6.5</p><p><strong>执行如下代码安装</strong></p><p><strong>···························**</strong>–prefix<strong><strong>选项是配置安装的路径,执行后所有资源文件放在</strong></strong>/usr/local/python3.6<strong>**的路径中</strong></p><p># ./configure –prefix=/usr/local/python3 –enable-optimizations  </p><p># make  </p><p># make install  </p><p><strong>终于可以修改软链接了</strong></p><p>[plain] <a href="https://blog.csdn.net/zzzcl112/article/details/80445642#" target="_blank" rel="noopener">view plain</a> <a href="https://blog.csdn.net/zzzcl112/article/details/80445642#" target="_blank" rel="noopener">copy</a></p><ol><li># ln -s /usr/local/python3/bin/python3 /usr/bin/python3  </li><li># ln -s /usr/local/python3/bin/pip3.6 /usr/bin/pip3  </li></ol><p>————————————-安装-virtualenv————————————–</p><p>使用编译安装python3过程中的pip包管理工具，安装virtualenv python环境隔离工具</p><p>pip3  installvirtualenv</p><p>在~/.bashrc文件中加上：</p><p>export PIP_REQUIRE_VIRTUALENV=true</p><p>或者让在执行pip的时候让系统自动开启虚拟环境：</p><p>export PIP_RESPECT_VIRTUALENV=true</p><p>source ~/.bashrc使其生效</p><p>建立python3独立环境</p><p>virtualenv  -p/usr/local/bin/python3 /py3env</p><p>使用python3环境</p><p>./py3env/bin/activate</p><p>安装Virtaulenvwrapper是virtualenv的扩展包，用于更方便管理虚拟环境</p><p>easy_installvirtualenvwrapper(这个过程有点慢，莫急)</p><p>此时还不能使用virtualenvwrapper，默认virtualenvwrapper安装在/usr/bin下面，实际上你需要运行virtualenvwrapper.sh文件才行，配置环境</p><p>打开~/.bashrc最终配置环境如下说明：</p><p>exportPIP_REQUIRE_VIRTUALENV=true</p><p>exportPIP_RESPECT_VIRTUALENV=true</p><p>exportWORKON_HOME=$HOME/.virtualenvs</p><p>source/usr/bin/virtualenvwrapper.sh</p><p>exportVIRTUALENVWRAPPER_PYTHON=/usr/bin/python2.7 #防止环境变量$PATH中已有其它环境的python</p><p>配置好后，source一下使其生效</p><p>使用virtualenvwrapper工具管理隔离环境命令如下：</p><p>列出虚拟环境列表</p><p>workon</p><p>也可以使用</p><p>lsvirtualenv</p><p>新建虚拟环境</p><p>mkvirtualenv [虚拟环境名称]</p><p>启动/切换虚拟环境</p><p>workon [虚拟环境名称]</p><p>删除虚拟环境</p><p>rmvirtualenv [虚拟环境名称]</p><p>离开虚拟环境</p><p>deactivate</p><p><em>查看当前虚拟环境所安装的包:</em></p><p>命令:pip list</p>]]></content>
      
      
      <categories>
          
          <category> Linux相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/26/hello-world/"/>
      <url>/2019/07/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
